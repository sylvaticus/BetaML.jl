<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A classification task when labels are known - determining the country of origin of cars given the cars characteristics · BetaML.jl Documentation</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-JYKX8QY5JW"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-JYKX8QY5JW', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../index.html">BetaML.jl Documentation</a></span></div><form class="docs-search" action="../../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../index.html">Index</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../Betaml_tutorial_getting_started.html">Getting started</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Regression - bike sharing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Regression - bike sharing/betaml_tutorial_regression_sharingBikes.html">A regression task: the prediction of  bike  sharing demand</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox" checked/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Classification - cars</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href="betaml_tutorial_classification_cars.html">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a><ul class="internal"><li><a class="tocitem" href="#Library-and-data-loading"><span>Library and data loading</span></a></li><li><a class="tocitem" href="#Random-Forests"><span>Random Forests</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Clustering - Iris</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Clustering - Iris/betaml_tutorial_cluster_iris.html">A clustering task: the prediction of  plant species from floreal measures (the iris dataset)</a></li></ul></li></ul></li><li><span class="tocitem">API (Reference manual)</span><ul><li><a class="tocitem" href="../../Perceptron.html">Perceptron</a></li><li><a class="tocitem" href="../../Trees.html">Trees</a></li><li><a class="tocitem" href="../../Nn.html">Nn</a></li><li><a class="tocitem" href="../../Clustering.html">Clustering</a></li><li><a class="tocitem" href="../../Utils.html">Utils</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li><a class="is-disabled">Classification - cars</a></li><li class="is-active"><a href="betaml_tutorial_classification_cars.html">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="betaml_tutorial_classification_cars.html">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sylvaticus/BetaML.jl/blob/master/docs/src/tutorials/Classification - cars/betaml_tutorial_classification_cars.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="classification_tutorial"><a class="docs-heading-anchor" href="#classification_tutorial">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a><a id="classification_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#classification_tutorial" title="Permalink"></a></h1><p>In this exercise we have some car technical characteristics (mpg, horsepower,weight, model year...) and the country of origin and we would like to create a model such that the country of origin can be accurately predicted given the technical characteristics. As the information to predict is a multi-class one, this is a <em>[classification]</em>(https://en.wikipedia.org/wiki/Statistical_classification) task. It is a challenging exercise due to the simultaneous presence of three factors: (1) presence of missing data; (2) unbalanced data - 254 out of 406 cars are US made; (3) small dataset.</p><p>Data origin:</p><ul><li>dataset description: <a href="https://archive.ics.uci.edu/ml/datasets/auto+mpg">https://archive.ics.uci.edu/ml/datasets/auto+mpg</a></li><li>data source we use here: <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data-original">https://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data</a></li></ul><p>Field description:</p><ol><li>mpg:           <em>continuous</em></li><li>cylinders:     <em>multi-valued discrete</em></li><li>displacement:  <em>continuous</em></li><li>horsepower:    <em>continuous</em></li><li>weight:        <em>continuous</em></li><li>acceleration:  <em>continuous</em></li><li>model year:    <em>multi-valued discrete</em></li><li>origin:        <em>multi-valued discrete</em></li><li>car name:      <em>string (unique for each instance)</em> - not used here</li></ol><p>!!! warning As the above example is automatically executed by GitHub on every code update, it uses parameters (epoch numbers, parameter space of hyperparameter validation, number of trees,...) that minimise the computation. In real case you will want to use better but more computationally intensive ones. For the same reason benchmarks codes are commented and the pre-run output reported rather than actually being executed.</p><h2 id="Library-and-data-loading"><a class="docs-heading-anchor" href="#Library-and-data-loading">Library and data loading</a><a id="Library-and-data-loading-1"></a><a class="docs-heading-anchor-permalink" href="#Library-and-data-loading" title="Permalink"></a></h2><p>We load a buch of packages that we&#39;ll use during this tutorial..</p><pre><code class="language-julia hljs">using Random, HTTP, CSV, DataFrames, BenchmarkTools, BetaML
import DecisionTree, Flux
import Pipe: @pipe</code></pre><p>To load the data from the internet our workflow is (1) Retrieve the data –&gt; (2) Clean it –&gt; (3) Load it –&gt; (4) Output it as a DataFrame.</p><p>For step (1) we use <code>HTTP.get()</code>, for step (2) we use <code>replace!</code>, for steps (3) and (4) we uses the <code>CSV</code> package, and we use the &quot;pip&quot; <code>|&gt;</code> operator to chain these operations:</p><pre><code class="language-julia hljs">urlDataOriginal = &quot;https://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data-original&quot;
data = @pipe HTTP.get(urlDataOriginal).body                                                |&gt;
             replace!(_, UInt8(&#39;\t&#39;) =&gt; UInt8(&#39; &#39;))                                        |&gt;
             CSV.File(_, delim=&#39; &#39;, missingstring=&quot;NA&quot;, ignorerepeated=true, header=false) |&gt;
             DataFrame;</code></pre><p>This results in a table where the rows are the observations (the various cars) and the column the fields. All BetaML models expect this layout.</p><p>As the dataset is ordered, we randomly shuffle the data. Note that we pass to shuffle <code>copy(FIXEDRNG)</code> as the random nuber generator in order to obtain reproducible output ( <a href="../../Utils.html#BetaML.Utils.FIXEDRNG"><code>FIXEDRNG</code></a> is nothing else than an istance of <code>StableRNG(123)</code> defined in the <a href="../../Utils.html#utils_module"><code>BetaML.Utils</code></a> sub-module, but you can choose of course your own &quot;fixed&quot; RNG). See the <a href="../Betaml_tutorial_getting_started.html#dealing_with_stochasticity">Dealing with stochasticity</a> section in the <a href="../Betaml_tutorial_getting_started.html#getting_started">Getting started</a> tutorial for details.</p><pre><code class="language-julia hljs">data[shuffle(copy(FIXEDRNG),axes(data, 1)), :]
describe(data)</code></pre><div class="data-frame"><p>9 rows × 7 columns</p><table class="data-frame"><thead><tr><th></th><th>variable</th><th>mean</th><th>min</th><th>median</th><th>max</th><th>nmissing</th><th>eltype</th></tr><tr><th></th><th title="Symbol">Symbol</th><th title="Union{Nothing, Float64}">Union…</th><th title="Any">Any</th><th title="Union{Nothing, Float64}">Union…</th><th title="Any">Any</th><th title="Int64">Int64</th><th title="Type">Type</th></tr></thead><tbody><tr><th>1</th><td>Column1</td><td>23.5146</td><td>9.0</td><td>23.0</td><td>46.6</td><td>8</td><td>Union{Missing, Float64}</td></tr><tr><th>2</th><td>Column2</td><td>5.47537</td><td>3.0</td><td>4.0</td><td>8.0</td><td>0</td><td>Float64</td></tr><tr><th>3</th><td>Column3</td><td>194.78</td><td>68.0</td><td>151.0</td><td>455.0</td><td>0</td><td>Float64</td></tr><tr><th>4</th><td>Column4</td><td>105.082</td><td>46.0</td><td>95.0</td><td>230.0</td><td>6</td><td>Union{Missing, Float64}</td></tr><tr><th>5</th><td>Column5</td><td>2979.41</td><td>1613.0</td><td>2822.5</td><td>5140.0</td><td>0</td><td>Float64</td></tr><tr><th>6</th><td>Column6</td><td>15.5197</td><td>8.0</td><td>15.5</td><td>24.8</td><td>0</td><td>Float64</td></tr><tr><th>7</th><td>Column7</td><td>75.9212</td><td>70.0</td><td>76.0</td><td>82.0</td><td>0</td><td>Float64</td></tr><tr><th>8</th><td>Column8</td><td>1.56897</td><td>1.0</td><td>1.0</td><td>3.0</td><td>0</td><td>Float64</td></tr><tr><th>9</th><td>Column9</td><td></td><td>amc ambassador brougham</td><td></td><td>vw rabbit custom</td><td>0</td><td>String</td></tr></tbody></table></div><p>Columns 1 to 7 contain  characteristics of the car, while column 8 encodes the country or origin (&quot;1&quot; -&gt; US, &quot;2&quot; -&gt; EU, &quot;3&quot; -&gt; Japan). That&#39;s the variable we want to be able to predict.</p><p>Columns 9 contains the car name, but we are not going to use this information in this tutorial. Note also that some fields have missing data.</p><p>Our first step is hence to divide the dataset in features (the x) and the labels (the y) we want to predict. The <code>x</code> is then a Julia standard <code>Matrix</code> of 406 rows by 7 columns and the <code>y</code> is a vector of the 406 observations:</p><pre><code class="language-julia hljs">x     = Matrix{Union{Missing,Float64}}(data[:,1:7]);
y     = Vector{Int64}(data[:,8]);</code></pre><p>Some algorithms that we will use today don&#39;t work with missing data, so we need to <em>impute</em> them. We use the <a href="../../Clustering.html#BetaML.Clustering.predictMissing"><code>predictMissing</code></a> function provided by the <a href="../../Clustering.html#clustering_module"><code>BetaML.Clustering</code></a> sub-module. Internally the function uses a Gaussian Mixture Model to assign to the missing walue of a given record an average of the values of the non-missing records weighted for how close they are to our specific record. Note that the same function (<code>predictMissing</code>) can be used for Collaborative Filtering / recomendation systems. Using GMM has the advantage over traditional algorithms as k-nearest neighbors (KNN) that GMM can &quot;detect&quot; the hidden structure of the observed data, where some observation can be similar to a certain pool of other observvations for a certain characteristic, but similar to an other pool of observations for other characteristics.</p><pre><code class="language-julia hljs">xFull = predictMissing(x,rng=copy(FIXEDRNG)).X̂;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iter. 1:	Var. of the post  20.10554158364678 	  Log-likelihood -12110.417616527317</code></pre><p>Further, some models don&#39;t work with categorical data as such, so we need to represent our <code>y</code> as a matrix with a separate column for each possible categorical value (the so called &quot;one-hot&quot; representation). For example, within a three classes field, the individual value <code>2</code> (or <code>&quot;Europe&quot;</code> for what it matters) would be represented as the vector <code>[0 1 0]</code>, while <code>3</code> (or <code>&quot;Japan&quot;</code>) would become the vector <code>[0 0 1]</code>. To encode as one-hot we use the function <a href="../../Utils.html#BetaML.Utils.oneHotEncoder-Union{Tuple{Union{AbstractVector{T}, T}}, Tuple{T}} where T"><code>oneHotEncoder</code></a> in <a href="../../Utils.html#utils_module"><code>BetaML.Utils</code></a></p><pre><code class="language-julia hljs">y_oh  = oneHotEncoder(y);</code></pre><p>In supervised machine learning it is good practice to partition the available data in a <em>training</em>, <em>validation</em>, and <em>test</em> subsets, where the first one is used to train the ML algorithm, the second one to train any eventual &quot;hyper-parameters&quot; of the algorithm and the <em>test</em> subset is finally used to evaluate the quality of the algorithm. Here, for brevity, we use only the <em>train</em> and the <em>test</em> subsets, implicitly assuming we already know the best hyper-parameters. Please refer to the <a href="../Regression - bike sharing/betaml_tutorial_regression_sharingBikes.html#regression_tutorial">regression tutorial</a> for examples of how to use the validation subset to train the hyper-parameters, or even better the <a href="../Clustering - Iris/betaml_tutorial_cluster_iris.html#clustering_tutorial">clustering tutorial</a> for an example of using the <a href="../../Utils.html#BetaML.Utils.crossValidation"><code>crossValidation</code></a> function.</p><p>We use then the <a href="../../Trees.html#BetaML.Api.partition-Union{Tuple{Tx}, Tuple{BetaML.Trees.Question{Tx}, Any, Any}} where Tx"><code>partition</code></a> function in <a href="../../Utils.html#utils_module">BetaML.Utils</a>, where we can specify the different data to partition (each matrix or vector to partition must have the same number of observations) and the shares of observation that we want in each subset. Here we keep 80% of observations for training (<code>xtrain</code>, <code>xTrainFull</code> and <code>ytrain</code>) and we use 20% of them for testing (<code>xtest</code>, <code>xTestFull</code> and <code>ytest</code>):</p><pre><code class="language-julia hljs">((xtrain,xtest),(xtrainFull,xtestFull),(ytrain,ytest),(ytrain_oh,ytest_oh)) = partition([x,xFull,y,y_oh],[0.8,1-0.8],rng=copy(FIXEDRNG));</code></pre><h2 id="Random-Forests"><a class="docs-heading-anchor" href="#Random-Forests">Random Forests</a><a id="Random-Forests-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Forests" title="Permalink"></a></h2><p>We are now ready to use our first model, the Random Forests (in the <a href="../../Trees.html#trees_module"><code>BetaML.Trees</code></a> sub-module). Random Forests build a &quot;forest&quot; of decision trees models and then average their predictions in order to make an overall prediction out of a feature vector.</p><p>To &quot;build&quot; the forest model (i.e. to &quot;train&quot; it) we need to give the model the training feature matrix and the associated &quot;true&quot; training labels, and we need to specify the number of trees to employ (this is an example of hyper-parameters). Here we use 30 individual decision trees.</p><p>As the labels are encoded using integers,  we need also to specify the parameter <code>forceClassification=true</code>, otherwise the model would undergo a <em>regression</em> job instead.</p><pre><code class="language-julia hljs">myForest       = buildForest(xtrain,ytrain,30, rng=copy(FIXEDRNG),forceClassification=true);</code></pre><p>To obtain the predicted values, we can simply use the function <a href="../../Perceptron.html#BetaML.Api.predict"><code>BetaML.Trees.predict</code></a> with our <code>myForest</code> model and either the training or the testing data.</p><pre><code class="language-julia hljs">ŷtrain,ŷtest   = predict.(Ref(myForest), [xtrain,xtest],rng=copy(FIXEDRNG));</code></pre><p>Finally we can measure the <em>accuracy</em> of our predictions with the <a href="../../Utils.html#BetaML.Utils.accuracy-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T"><code>accuracy</code></a> function, with the sidenote that we need first to &quot;parse&quot; the ŷs as forcing the classification job transformed automatically them to strings (they originally were integers):</p><pre><code class="language-julia hljs">trainAccuracy,testAccuracy  = accuracy.([parse.(Int64,mode(ŷtrain,rng=copy(FIXEDRNG))),parse.(Int64,mode(ŷtest,rng=copy(FIXEDRNG)))],[ytrain,ytest])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.9969230769230769
 0.8024691358024691</code></pre><p>The predictions are quite good, for the training set the algoritm predicted almost all cars&#39; origins correctly, while for the testing set (i.e. those records that has <strong>not</strong> been used to train the algorithm), the correct prediction level is still quite high, at 80%</p><p>While accuracy can sometimes suffice, we may often want to better understand which categories our model has trouble to predict correctly. We can investigate the output of a multi-class classifier more in-deep with a <a href="../../Utils.html#BetaML.Utils.ConfusionMatrix"><code>ConfusionMatrix</code></a> where the true values (<code>y</code>) are given in rows and the predicted ones (<code>ŷ</code>) in columns, together to some per-class metrics like the <em>precision</em> (true class <em>i</em> over predicted in class <em>i</em>), the <em>recall</em> (predicted class <em>i</em> over the true class <em>i</em>) and others.</p><p>We fist build the <a href="../../Utils.html#BetaML.Utils.ConfusionMatrix"><code>ConfusionMatrix</code></a> object between <code>ŷ</code> and <code>y</code> and then we print it (we do it here for the test subset):</p><pre><code class="language-julia hljs">cm = ConfusionMatrix(parse.(Int64,mode(ŷtest,rng=copy(FIXEDRNG))),ytest,classes=[1,2,3],labels=[&quot;US&quot;,&quot;EU&quot;,&quot;Japan&quot;])
print(cm,&quot;all&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
-----------------------------------------------------------------

*** CONFUSION MATRIX ***

Scores actual (rows) vs predicted (columns):

4×4 Matrix{Any}:
 &quot;Labels&quot;    &quot;US&quot;    &quot;EU&quot;   &quot;Japan&quot;
 &quot;US&quot;      43       3      3
 &quot;EU&quot;       2      13      1
 &quot;Japan&quot;    5       2      9
Normalised scores actual (rows) vs predicted (columns):

4×4 Matrix{Any}:
 &quot;Labels&quot;   &quot;US&quot;      &quot;EU&quot;       &quot;Japan&quot;
 &quot;US&quot;      0.877551  0.0612245  0.0612245
 &quot;EU&quot;      0.125     0.8125     0.0625
 &quot;Japan&quot;   0.3125    0.125      0.5625
 *** CONFUSION REPORT ***

- Accuracy:               0.8024691358024691
- Misclassification rate: 0.19753086419753085
- Number of classes:      3

  N Class   precision   recall  specificity  f1Score  actualCount  predictedCount
                          TPR       TNR                 support

  1 US          0.860    0.878        0.781    0.869           49              50
  2 EU          0.722    0.812        0.923    0.765           16              18
  3 Japan       0.692    0.562        0.938    0.621           16              13

- Simple   avg.    0.758    0.751        0.881    0.751
- Weigthed avg.    0.800    0.802        0.840    0.799

-----------------------------------------------------------------</code></pre><p>From the report we can see that Japanese cars have more trouble in being correctly classified, and in particular many Japanease cars are classified as US ones. This is likely a result of the class imbalance of the data set, and could be solved by balancing the dataset with various sampling tecniques before training the model.</p><p>When we benchmark the resourse used (time and memory) we find that Random Forests remain pretty fast, expecially when we compare them with neural networks (see later) @btime buildForest(xtrain,ytrain,30, rng=copy(FIXEDRNG),forceClassification=true); 134.096 ms (781027 allocations: 196.30 MiB)</p><h3 id="Comparision-with-DecisionTree.jl"><a class="docs-heading-anchor" href="#Comparision-with-DecisionTree.jl">Comparision with DecisionTree.jl</a><a id="Comparision-with-DecisionTree.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Comparision-with-DecisionTree.jl" title="Permalink"></a></h3><p>DecisionTrees.jl random forests are similar in usage: we first &quot;build&quot; (train) the forest and we then make predictions out of the trained model. The main difference is that the model requires data with nonmissing values, so we are going to use the <code>xtrainFull</code> and <code>xtestFull</code> feature labels we created earlier:</p><pre><code class="language-julia hljs"># We train the model...
model = DecisionTree.build_forest(ytrain, xtrainFull,-1,30,rng=123)
# ..and we generate predictions and measure their error
(ŷtrain,ŷtest) = DecisionTree.apply_forest.([model],[xtrainFull,xtestFull]);
(trainAccuracy,testAccuracy) = accuracy.([ŷtrain,ŷtest],[ytrain,ytest])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.9969230769230769
 0.7530864197530864</code></pre><p>While the accuracy on the training set is exactly the same as for <code>BetaML</code> random forets, <code>DecisionTree.jl</code> random forests are slighly less accurate in the testing sample. Where however <code>DecisionTrees.jl</code> excell is in the efficiency: they are extremelly fast and memory thrifty, even if to this benchmark we should add the resources needed to impute the missing values.</p><p>Also, one of the reasons DecisionTrees are such efficient is that internally they sort the data to avoid repeated comparision, but in this way they work only with features that are sortable, while BetaML random forests accept virtually any kind of input without the need of adapt it. @btime  DecisionTree.build_forest(ytrain, xtrainFull,-1,30,rng=123); 1.431 ms (10875 allocations: 1.52 MiB)</p><h3 id="Neural-network"><a class="docs-heading-anchor" href="#Neural-network">Neural network</a><a id="Neural-network-1"></a><a class="docs-heading-anchor-permalink" href="#Neural-network" title="Permalink"></a></h3><p>Neural networks (NN) can be very powerfull, but have two &quot;inconvenients&quot; compared with random forests: first, are a bit &quot;picky&quot;. We need to do a bit of work to provide data in specific format. Note that this is <em>not</em> feature engineering. One of the advantages on neural network is that for the most this is not needed for neural networks. However we still need to &quot;clean&quot; the data. One issue is that NN don&#39;t like missing data. So we need to provide them with the feature matrix &quot;clean&quot; of missing data. Secondly, they work only with numerical data. So we need to use the one-hot encoding we saw earlier. Further, they work best if the features are scaled such that each feature has mean zero and standard deviation 1. We can achieve it with the function <a href="../../Utils.html#BetaML.Utils.scale"><code>scale</code></a> or, as in this case, <a href="../../Utils.html#BetaML.Utils.getScaleFactors-Tuple{Any}"><code>getScaleFactors</code></a>.</p><pre><code class="language-julia hljs">xScaleFactors   = getScaleFactors(xtrainFull)
D               = size(xtrainFull,2)
classes         = unique(y)
nCl             = length(classes)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3</code></pre><p>The second &quot;inconvenient&quot; of NN is that, while not requiring feature engineering, they stil lneed a bit of practice on the way to build the network. It&#39;s not as simple as <code>train(model,x,y)</code>. We need here to specify how we want our layers, <em>chain</em> the layers together and then decide a <em>loss</em> overall function. Only when we done these steps, we have the model ready for training. Here we define 2 <a href="../../Nn.html#BetaML.Nn.DenseLayer"><code>DenseLayer</code></a> where, for each of them, we specify the number of neurons in input (the first layer being equal to the dimensions of the data), the output layer (for a classification task, the last layer output size beying equal to the number of classes) and an <em>activation function</em> for each layer (default the <code>identity</code> function).</p><pre><code class="language-julia hljs">ls   = 50
l1   = DenseLayer(D,ls,f=relu,rng=copy(FIXEDRNG))
l2   = DenseLayer(ls,nCl,f=relu,rng=copy(FIXEDRNG))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DenseLayer([-0.2146463925907584 -0.3077087587320811 … -0.28256208289474877 0.21510681158042189; -0.08916953797649538 -0.041727530915651345 … -0.30444064706465346 -0.22349634154766507; 0.11376391271810127 -0.011244515923068743 … 0.12916068649773038 -0.2518581440082599], [0.2918467648814228, -0.004167534280141383, 0.29060333096888613], BetaML.Utils.relu, nothing)</code></pre><p>For a classification the last layer is a <a href="../../Nn.html#BetaML.Nn.VectorFunctionLayer"><code>VectorFunctionLayer</code></a> that has no learnable parameters but whose activation function is applied to the ensemble of the neurons, rather than individually on each neuron. In particular, for classification we pass the <a href="../../Utils.html#BetaML.Utils.softmax-Tuple{Any}"><code>BetaML.Utils.softmax</code></a> function whose output has the same size as the input (and the number of classes to predict), but we can use the <code>VectorFunctionLayer</code> with any function, including the <a href="../../Utils.html#BetaML.Utils.pool1d"><code>pool1d</code></a> function to create a &quot;pooling&quot; layer (using maximum, mean or whatever other subfunction we pass to <code>pool1d</code>)</p><pre><code class="language-julia hljs">l3   = VectorFunctionLayer(nCl,f=softmax) ## Add a (parameterless) layer whose activation function (softMax in this case) is defined to all its nodes at once</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VectorFunctionLayer{0}(fill(NaN), 3, 3, BetaML.Utils.softmax, nothing, nothing)</code></pre><p>Finally we <em>chain</em> the layers and assign a loss function with <a href="../../Nn.html#BetaML.Nn.buildNetwork-Tuple{Any, Any}"><code>buildNetwork</code></a>:</p><pre><code class="language-julia hljs">mynn = buildNetwork([l1,l2,l3],squaredCost,name=&quot;Multinomial logistic regression Model Cars&quot;) ## Build the NN and use the squared cost (aka MSE) as error function (crossEntropy could also be used)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NN(AbstractLayer[DenseLayer([-0.20697795942360017 0.12136901733806621 … -0.026906267639792758 -0.08117976159071413; -0.08598387697252577 -0.094763858010351 … 0.12473600153619574 -0.3038923887271602; … ; -0.027245366184114994 -0.13726439265473928 … -0.0812568745415187 0.03639080823771723; 0.21807051339784328 -0.04462192007289573 … -0.09201125674551605 -0.25212961016223523], [-0.32359467997037583, 0.15252213461474667, 0.05681391283261772, -0.0718950523804685, 0.014112894961209654, 0.250715710684788, -0.08912986019414143, -0.22300278678968377, 0.011113501374895696, -0.2307615737177409  …  -0.06868980831928373, 0.22894772322501816, 0.19247052748600918, 0.3243004525232283, -0.005682087946757619, 0.3173647151609262, -0.0419358245557761, 0.1792922925250479, 0.11465680902201164, -0.049714381947920605], BetaML.Utils.relu, nothing), DenseLayer([-0.2146463925907584 -0.3077087587320811 … -0.28256208289474877 0.21510681158042189; -0.08916953797649538 -0.041727530915651345 … -0.30444064706465346 -0.22349634154766507; 0.11376391271810127 -0.011244515923068743 … 0.12916068649773038 -0.2518581440082599], [0.2918467648814228, -0.004167534280141383, 0.29060333096888613], BetaML.Utils.relu, nothing), VectorFunctionLayer{0}(fill(NaN), 3, 3, BetaML.Utils.softmax, nothing, nothing)], BetaML.Utils.squaredCost, nothing, false, &quot;Multinomial logistic regression Model Cars&quot;)</code></pre><p>Now we can train our network using the function <a href="../../Clustering.html#BetaML.Api.train!-Tuple{GMMClusterModel, Any}"><code>train!</code></a>. It has many options, have a look at the documentation for all the possible arguments. Note that we train the network based on the scaled feature matrix.</p><pre><code class="language-julia hljs">res  = train!(mynn,scale(xtrainFull,xScaleFactors),ytrain_oh,epochs=500,batchSize=8,optAlg=ADAM(),rng=copy(FIXEDRNG)) ## Use optAlg=SGD() to use Stochastic Gradient Descent instead</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(epochs = 500, ϵ_epochs = [0.394793346671227, 0.2807328464303103, 0.22540959714717967, 0.20450202312391905, 0.19136110202105652, 0.18291741833577554, 0.1776076248872656, 0.17366196897056083, 0.17063394724512324, 0.16751743542979855  …  0.0679895570803899, 0.06785310875861966, 0.06805147075129538, 0.06843456668489703, 0.06792390250775654, 0.06790615579332533, 0.06768486549836293, 0.06777986689954778, 0.06775912020670324, 0.06776877566449145], θ_epochs = Any[])</code></pre><p>Once trained, we can predict the label. As the trained was based on the scaled feature matrix, so must be for the predictions</p><pre><code class="language-julia hljs">(ŷtrain,ŷtest)  = predict.(Ref(mynn),[scale(xtrainFull,xScaleFactors),scale(xtestFull,xScaleFactors)])
trainAccuracy   = accuracy(ŷtrain,ytrain,rng=copy(FIXEDRNG))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.8953846153846153</code></pre><pre><code class="language-julia hljs">testAccuracy    = accuracy(ŷtest,ytest,rng=copy(FIXEDRNG))



cm = ConfusionMatrix(ŷtest,ytest,classes=[1,2,3],labels=[&quot;US&quot;,&quot;EU&quot;,&quot;Japan&quot;],rng=copy(FIXEDRNG))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConfusionMatrix{Int64}([1, 2, 3], [&quot;US&quot;, &quot;EU&quot;, &quot;Japan&quot;], 0.7654320987654321, 0.23456790123456794, [49, 16, 16], [53, 12, 16], [44 0 5; 3 10 3; 6 2 8], [0.8979591836734694 0.0 0.10204081632653061; 0.1875 0.625 0.1875; 0.375 0.125 0.5], [44, 10, 8], [23, 63, 57], [9, 2, 8], [5, 6, 8], [0.8301886792452831, 0.8333333333333334, 0.5], [0.8979591836734694, 0.625, 0.5], [0.71875, 0.9692307692307692, 0.8769230769230769], [0.8627450980392157, 0.7142857142857143, 0.5], (0.7211740041928721, 0.7655873903253358), (0.6743197278911565, 0.7654320987654321), (0.8549679487179488, 0.7994717473884142), (0.6923436041083101, 0.7617664349690494))</code></pre><p>print(cm)</p><p>4×4 Matrix{Any}:  &quot;Labels&quot;    &quot;US&quot;    &quot;EU&quot;   &quot;Japan&quot;  &quot;US&quot;      44       0      5  &quot;EU&quot;       3      10      3  &quot;Japan&quot;    6       2      8 4×4 Matrix{Any}:  &quot;Labels&quot;   &quot;US&quot;      &quot;EU&quot;   &quot;Japan&quot;  &quot;US&quot;      0.897959  0.0    0.102041  &quot;EU&quot;      0.1875    0.625  0.1875  &quot;Japan&quot;   0.375     0.125  0.5</p><p>We see a bit the limits of neural networks in this example. While NN can be extremelly performant in many domains, they also require lot of data and computational power, expecially considering the many possible hyper-parameters and hence its large space in the hyper-parameter tuning. In this example we arrive short to the performance of random forests, yet with a significant numberof neurons.</p><p>@btime train!(mynn,scale(xtrainFull),ytrain_oh,epochs=300,batchSize=8,rng=copy(FIXEDRNG),verbosity=NONE); 11.841 s (62860672 allocations: 4.21 GiB)</p><h3 id="Comparisons-with-Flux"><a class="docs-heading-anchor" href="#Comparisons-with-Flux">Comparisons with Flux</a><a id="Comparisons-with-Flux-1"></a><a class="docs-heading-anchor-permalink" href="#Comparisons-with-Flux" title="Permalink"></a></h3><p>In Flux the input must be in the form (fields, observations), so we transpose our original matrices</p><pre><code class="language-julia hljs">xtrainT, ytrain_ohT = transpose.([scale(xtrainFull,xScaleFactors), ytrain_oh])
xtestT, ytest_ohT   = transpose.([scale(xtestFull,xScaleFactors), ytest_oh])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{LinearAlgebra.Transpose{Float64, Matrix{Float64}}}:
 [-0.935469112186713 0.8211030586728019 … 1.6357452248685187 -0.5790631644760867; 0.3321589709665675 -0.8476406526851751 … -0.25774084085930377 0.3321589709665675; … ; 0.08499289148757139 2.234618551678946 … 1.5539037592850098 -0.022488391521997587; 0.582575265003537 1.1235380110782482 … 1.1235380110782482 -1.3107943462579525]
 [0.0 0.0 … 0.0 1.0; 1.0 1.0 … 1.0 0.0; 0.0 0.0 … 0.0 0.0]</code></pre><p>We define the Flux neural network model in a similar way than BetaML and load it with data, we train it, predict and measure the accuracies on the training and the test sets:</p><pre><code class="language-julia hljs">Random.seed!(123)

l1         = Flux.Dense(D,ls,Flux.relu)
#l2         = Flux.Dense(ls,ls,Flux.relu)
l3         = Flux.Dense(ls,nCl,Flux.relu)
Flux_nn    = Flux.Chain(l1,l3)
loss(x, y) = Flux.logitcrossentropy(Flux_nn(x), y)
ps         = Flux.params(Flux_nn)
nndata     = Flux.Data.DataLoader((xtrainT, ytrain_ohT), batchsize=8,shuffle=true)
begin for i in 1:500  Flux.train!(loss, ps, nndata, Flux.ADAM()) end end
ŷtrain     = Flux.onecold(Flux_nn(xtrainT),1:3)
ŷtest      = Flux.onecold(Flux_nn(xtestT),1:3)
trainAccuracy =  accuracy(ŷtrain,ytrain)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9446153846153846</code></pre><pre><code class="language-julia hljs">testAccuracy  = accuracy(ŷtest,ytest)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.7407407407407407</code></pre><p>While the train accuracy is little bit higher that BetaML, the test accuracy remains comparable</p><p>However the time is again lower than BetaML, even if here for &quot;just&quot; a factor 2 @btime begin for i in 1:500 Flux.train!(loss, ps, nndata, Flux.ADAM()) end end; 5.665 s (8943640 allocations: 1.07 GiB)</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This is the summary of the results we had trying to predict the country of origin of the cars, based on their technical characteristics:</p><table><tr><th style="text-align: left">Model</th><th style="text-align: center">Train acc</th><th style="text-align: right">Test Acc</th><th style="text-align: right">Training time (ms)*</th><th style="text-align: right">Training mem (MB) *</th></tr><tr><td style="text-align: left">RF</td><td style="text-align: center">0.9969</td><td style="text-align: right">0.8025</td><td style="text-align: right">134</td><td style="text-align: right">196</td></tr><tr><td style="text-align: left">RF (DecisionTree.jl)</td><td style="text-align: center">0.9969</td><td style="text-align: right">0.7531</td><td style="text-align: right">1.43</td><td style="text-align: right">1.5</td></tr><tr><td style="text-align: left">NN</td><td style="text-align: center">0.895</td><td style="text-align: right">0.765</td><td style="text-align: right">11841</td><td style="text-align: right">4311</td></tr><tr><td style="text-align: left">NN (Flux.jl)</td><td style="text-align: center">0.938</td><td style="text-align: right">0.741</td><td style="text-align: right">5665</td><td style="text-align: right">1096</td></tr></table><ul><li>on a Intel Core i5-8350U laptop</li></ul><p>We warn that this table just provides a rought idea of the various algorithms performances. Indeed there is a large amount of stochasticity both in the sampling of the data used for training/testing and in the initial settings of the parameters of the algorithm. For a statistically significant comparision we would have to repeat the analysis with multiple sampling (e.g. by cross-validation, see the <a href="../Clustering - Iris/betaml_tutorial_cluster_iris.html#clustering_tutorial">clustering tutorial</a> for an example) and initial random parameters.</p><p>Neverthless the table above shows that, when we compare BetaML with the algorithm-specific leading packages, we found similar results in terms of accuracy, but often the leading packages are better optimised and run more efficiently (but sometimes at the cost of being less verstatile). Also, for this dataset, Random Forests seems to remain marginally more accurate than Neural Network, altought of course this depends on the hyper-parameters and, with a single run of the models, we don&#39;t know if this difference is significant.</p><p><a href="https://github.com/sylvaticus/BetaML.jl/blob/master/docs/src/tutorials/Classification - cars/betaml_tutorial_classification_cars.jl">View this file on Github</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Regression - bike sharing/betaml_tutorial_regression_sharingBikes.html">« A regression task: the prediction of  bike  sharing demand</a><a class="docs-footer-nextpage" href="../Clustering - Iris/betaml_tutorial_cluster_iris.html">A clustering task: the prediction of  plant species from floreal measures (the iris dataset) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Thursday 28 July 2022 03:35">Thursday 28 July 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
