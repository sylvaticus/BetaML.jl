<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nn · BetaML.jl Documentation</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-JYKX8QY5JW"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-JYKX8QY5JW', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">BetaML.jl Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Index</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="tutorials/Betaml_tutorial_getting_started.html">Getting started</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Regression - bike sharing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tutorials/Regression - bike sharing/betaml_tutorial_regression_sharingBikes.html">A regression task: the prediction of  bike  sharing demand</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Classification - cars</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tutorials/Classification - cars/betaml_tutorial_classification_cars.html">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Clustering - Iris</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tutorials/Clustering - Iris/betaml_tutorial_cluster_iris.html">A clustering task: the prediction of  plant species from floreal measures (the iris dataset)</a></li></ul></li></ul></li><li><span class="tocitem">API (Reference manual)</span><ul><li><a class="tocitem" href="Perceptron.html">Perceptron</a></li><li><a class="tocitem" href="Trees.html">Trees</a></li><li class="is-active"><a class="tocitem" href="Nn.html">Nn</a><ul class="internal"><li><a class="tocitem" href="#Module-Index"><span>Module Index</span></a></li><li><a class="tocitem" href="#Detailed-API"><span>Detailed API</span></a></li></ul></li><li><a class="tocitem" href="Clustering.html">Clustering</a></li><li><a class="tocitem" href="Utils.html">Utils</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API (Reference manual)</a></li><li class="is-active"><a href="Nn.html">Nn</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Nn.html">Nn</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sylvaticus/BetaML.jl/blob/master/docs/src/Nn.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="nn_module"><a class="docs-heading-anchor" href="#nn_module">The BetaML.Nn Module</a><a id="nn_module-1"></a><a class="docs-heading-anchor-permalink" href="#nn_module" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn" href="#BetaML.Nn"><code>BetaML.Nn</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">BetaML.Nn module</code></pre><p>Implement the functionality required to define an artificial Neural Network, train it with data, forecast data and assess its performances.</p><p>Common type of layers and optimisation algorithms are already provided, but you can define your own ones subclassing respectively the <code>AbstractLayer</code> and <code>OptimisationAlgorithm</code> abstract types.</p><p>The module provide the following type or functions. Use <code>?[type or function]</code> to access their full signature and detailed documentation:</p><p><strong>Model definition:</strong></p><ul><li><code>DenseLayer</code>: Classical feed-forward layer with user-defined activation function</li><li><code>DenseNoBiasLayer</code>: Classical layer without the bias parameter</li><li><code>VectorFunctionLayer</code>: Parameterless layer whose activation function run over the ensable of its nodes rather than on each one individually</li><li><code>buildNetwork</code>: Build the chained network and define a cost function</li><li><code>getParams(nn)</code>: Retrieve current weigthts</li><li><code>getGradient(nn)</code>: Retrieve the current gradient of the weights</li><li><code>setParams!(nn)</code>: Update the weigths of the network</li><li><code>show(nn)</code>: Print a representation of the Neural Network</li></ul><p>Each layer can use a default activation function, one of the functions provided in the <code>Utils</code> module (<code>relu</code>, <code>tanh</code>, <code>softmax</code>,...) or you can specify your own function. The derivative of the activation function can be optionally be provided, in such case training will be quicker, altought this difference tends to vanish with bigger datasets. You can alternativly implement your own layer defining a new type as subtype of the abstract type <code>AbstractLayer</code>. Each user-implemented layer must define the following methods:</p><ul><li>A suitable constructor</li><li><code>forward(layer,x)</code></li><li><code>backward(layer,x,nextGradient)</code></li><li><code>getParams(layer)</code></li><li><code>getGradient(layer,x,nextGradient)</code></li><li><code>setParams!(layer,w)</code></li><li><code>size(layer)</code></li></ul><p><strong>Model training:</strong></p><ul><li><code>trainingInfo(nn)</code>: Default callback function during training</li><li><code>train!(nn)</code>:  Training function</li><li><code>singleUpdate!(θ,▽;optAlg)</code>: The parameter update made by the specific optimisation algorithm</li><li><code>SGD</code>: The default optimisation algorithm</li><li><code>ADAM</code>: A faster moment-based optimisation algorithm (added in v0.2.2)</li></ul><p>To define your own optimisation algorithm define a subtype of <code>OptimisationAlgorithm</code> and implement the function <code>singleUpdate!(θ,▽;optAlg)</code> and eventually <code>initOptAlg(⋅)</code> specific for it.</p><p><strong>Model predictions and assessment:</strong></p><ul><li><code>predict(nn)</code>: Return the output given the data</li><li><code>loss(nn)</code>: Compute avg. network loss on a test set</li><li><code>Utils.accuracy(ŷ,y)</code>: Categorical output accuracy</li></ul><p>While high-level functions operating on the dataset expect it to be in the standard format (nRecords × nDimensions matrices) it is custom to represent the chain of a neural network as a flow of column vectors, so all low-level operations (operating on a single datapoint) expect both the input and the output as a column vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L17-L65">source</a></section></article><h2 id="Module-Index"><a class="docs-heading-anchor" href="#Module-Index">Module Index</a><a id="Module-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Index" title="Permalink"></a></h2><ul><li><a href="Nn.html#BetaML.Nn.ADAM"><code>BetaML.Nn.ADAM</code></a></li><li><a href="Nn.html#BetaML.Nn.DenseLayer"><code>BetaML.Nn.DenseLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.DenseNoBiasLayer"><code>BetaML.Nn.DenseNoBiasLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.Learnable"><code>BetaML.Nn.Learnable</code></a></li><li><a href="Nn.html#BetaML.Nn.NN"><code>BetaML.Nn.NN</code></a></li><li><a href="Nn.html#BetaML.Nn.OptimisationAlgorithm"><code>BetaML.Nn.OptimisationAlgorithm</code></a></li><li><a href="Nn.html#BetaML.Nn.RNNLayer"><code>BetaML.Nn.RNNLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.SGD"><code>BetaML.Nn.SGD</code></a></li><li><a href="Nn.html#BetaML.Nn.ScalarFunctionLayer"><code>BetaML.Nn.ScalarFunctionLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.VectorFunctionLayer"><code>BetaML.Nn.VectorFunctionLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.backward-Tuple{AbstractLayer, Any, Any}"><code>BetaML.Nn.backward</code></a></li><li><a href="Nn.html#BetaML.Nn.buildNetwork-Tuple{Any, Any}"><code>BetaML.Nn.buildNetwork</code></a></li><li><a href="Nn.html#BetaML.Nn.forward-Tuple{AbstractLayer, Any}"><code>BetaML.Nn.forward</code></a></li><li><a href="Nn.html#BetaML.Nn.getGradient-Tuple{AbstractLayer, Any, Any}"><code>BetaML.Nn.getGradient</code></a></li><li><a href="Nn.html#BetaML.Nn.getGradient-Union{Tuple{T2}, Tuple{T}, Tuple{Any, AbstractMatrix{T}, AbstractMatrix{T2}}} where {T&lt;:Number, T2&lt;:Number}"><code>BetaML.Nn.getGradient</code></a></li><li><a href="Nn.html#BetaML.Nn.getGradient-Union{Tuple{T2}, Tuple{T}, Tuple{NN, Union{AbstractVector{T}, T}, Union{AbstractVector{T2}, T2}}} where {T&lt;:Number, T2&lt;:Number}"><code>BetaML.Nn.getGradient</code></a></li><li><a href="Nn.html#BetaML.Nn.getNParams-Tuple{NN}"><code>BetaML.Nn.getNParams</code></a></li><li><a href="Nn.html#BetaML.Nn.getNParams-Tuple{AbstractLayer}"><code>BetaML.Nn.getNParams</code></a></li><li><a href="Nn.html#BetaML.Nn.getParams-Tuple{AbstractLayer}"><code>BetaML.Nn.getParams</code></a></li><li><a href="Nn.html#BetaML.Nn.getParams-Tuple{NN}"><code>BetaML.Nn.getParams</code></a></li><li><a href="Nn.html#BetaML.Nn.initOptAlg!-Tuple{ADAM}"><code>BetaML.Nn.initOptAlg!</code></a></li><li><a href="Nn.html#BetaML.Nn.initOptAlg!-Tuple{BetaML.Nn.OptimisationAlgorithm}"><code>BetaML.Nn.initOptAlg!</code></a></li><li><a href="Nn.html#BetaML.Nn.loss-Tuple{NN, Any, Any}"><code>BetaML.Nn.loss</code></a></li><li><a href="Nn.html#BetaML.Nn.setParams!-Tuple{AbstractLayer, Any}"><code>BetaML.Nn.setParams!</code></a></li><li><a href="Nn.html#BetaML.Nn.setParams!-Tuple{NN, Any}"><code>BetaML.Nn.setParams!</code></a></li><li><a href="Nn.html#BetaML.Nn.show-Tuple{NN}"><code>BetaML.Nn.show</code></a></li><li><a href="Nn.html#BetaML.Nn.singleUpdate!-Tuple{Any, Any}"><code>BetaML.Nn.singleUpdate!</code></a></li><li><a href="Nn.html#BetaML.Nn.trainingInfo-Tuple{Any, Any, Any}"><code>BetaML.Nn.trainingInfo</code></a></li></ul><h2 id="Detailed-API"><a class="docs-heading-anchor" href="#Detailed-API">Detailed API</a><a id="Detailed-API-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.ADAM" href="#BetaML.Nn.ADAM"><code>BetaML.Nn.ADAM</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ADAM(;η, λ, β₁, β₂, ϵ)</p><p>The <a href="https://arxiv.org/pdf/1412.6980.pdf">ADAM</a> algorithm, an adaptive moment estimation optimiser.</p><p><strong>Fields:</strong></p><ul><li><code>η</code>:  Learning rate (stepsize, α in the paper), as a function of the current epoch [def: t -&gt; 0.001 (i.e. fixed)]</li><li><code>λ</code>:  Multiplicative constant to the learning rate [def: 1]</li><li><code>β₁</code>: Exponential decay rate for the first moment estimate [range: ∈ [0,1], def: 0.9]</li><li><code>β₂</code>: Exponential decay rate for the second moment estimate [range: ∈ [0,1], def: 0.999]</li><li><code>ϵ</code>:  Epsilon value to avoid division by zero [def: 10^-8]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn_default_optalgs.jl#L46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.DenseLayer" href="#BetaML.Nn.DenseLayer"><code>BetaML.Nn.DenseLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DenseLayer</p><p>Representation of a layer in the network</p><p><strong>Fields:</strong></p><ul><li><code>w</code>:  Weigths matrix with respect to the input from previous layer or data (n x n pr. layer)</li><li><code>wb</code>: Biases (n)</li><li><code>f</code>:  Activation function</li><li><code>df</code>: Derivative of the activation function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn_default_layers.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.DenseNoBiasLayer" href="#BetaML.Nn.DenseNoBiasLayer"><code>BetaML.Nn.DenseNoBiasLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DenseNoBiasLayer</p><p>Representation of a layer without bias in the network</p><p><strong>Fields:</strong></p><ul><li><code>w</code>:  Weigths matrix with respect to the input from previous layer or data (n x n pr. layer)</li><li><code>f</code>:  Activation function</li><li><code>df</code>: Derivative of the activation function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn_default_layers.jl#L119-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.Learnable" href="#BetaML.Nn.Learnable"><code>BetaML.Nn.Learnable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Learnable(data)</p><p>Structure representing the learnable parameters of a layer or its gradient.</p><p>The learnable parameters of a layers are given in the form of a N-tuple of Array{Float64,N2} where N2 can change (e.g. we can have a layer with the first parameter being a matrix, and the second one being a scalar). We wrap the tuple on its own structure a bit for some efficiency gain, but above all to define standard mathematic operations on the gradients without doing &quot;type pyracy&quot; with respect to Base tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L88-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.NN" href="#BetaML.Nn.NN"><code>BetaML.Nn.NN</code></a> — <span class="docstring-category">Type</span></header><section><div><p>NN</p><p>Representation of a Neural Network</p><p><strong>Fields:</strong></p><ul><li><code>layers</code>:  Array of layers objects</li><li><code>cf</code>:      Cost function</li><li><code>dcf</code>:     Derivative of the cost function</li><li><code>trained</code>: Control flag for trained networks</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L281-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.OptimisationAlgorithm" href="#BetaML.Nn.OptimisationAlgorithm"><code>BetaML.Nn.OptimisationAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OptimisationAlgorithm</code></pre><p>Abstract type representing an Optimisation algorithm.</p><p>Currently supported algorithms:</p><ul><li><code>SGD</code> (Stochastic) Gradient Descent</li><li><code>ADAM</code> The ADAM algorithm, an adaptive moment estimation optimiser.</li></ul><p>See <code>?[Name OF THE ALGORITHM]</code> for their details</p><p>You can implement your own optimisation algorithm using a subtype of <code>OptimisationAlgorithm</code> and implementing its constructor and the update function <code>singleUpdate(⋅)</code> (type <code>?singleUpdate</code> for details).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L524-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.RNNLayer" href="#BetaML.Nn.RNNLayer"><code>BetaML.Nn.RNNLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>RNNLayer</p><p>Representation of a layer in the network</p><p><strong>Fields:</strong></p><ul><li><code>wx</code>: Weigths matrix with respect to the input from data (n by n_input)</li><li><code>ws</code>: Weigths matrix with respect to the layer state (n x n )</li><li><code>wb</code>: Biases (n)</li><li><code>f</code>:  Activation function</li><li><code>df</code>: Derivative of the activation function</li><li><code>s</code> : State</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn_default_layers.jl#L474-L486">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.SGD" href="#BetaML.Nn.SGD"><code>BetaML.Nn.SGD</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SGD(;η=t -&gt; 1/(1+t), λ=2)</p><p>Stochastic Gradient Descent algorithm (default)</p><p><strong>Fields:</strong></p><ul><li><code>η</code>: Learning rate, as a function of the current epoch [def: t -&gt; 1/(1+t)]</li><li><code>λ</code>: Multiplicative constant to the learning rate [def: 2]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn_default_optalgs.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.ScalarFunctionLayer" href="#BetaML.Nn.ScalarFunctionLayer"><code>BetaML.Nn.ScalarFunctionLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ScalarFunctionLayer</p><p>Representation of a ScalarFunction layer in the network. ScalarFunctionLayer applies the activation function directly to the output of the previous layer (i.e., without passing for a weigth matrix), but using an  optional learnable parameter (an array) used as second argument, similarly to [<code>VectorFunctionLayer</code>(@ref). Differently from <code>VectorFunctionLayer</code>, the function is applied scalarwise to each node. </p><p>The number of nodes in input must be set to the same as in the previous layer</p><p><strong>Fields:</strong></p><ul><li><code>w</code>:   Weigths (parameter) array passes as second argument to the activation        function (if not empty)</li><li><code>n</code>:   Number of nodes in output (≡ number of nodes in input )</li><li><code>f</code>:   Activation function (vector)</li><li><code>dfx</code>: Derivative of the (vector) activation function with respect to the        layer inputs (x)</li><li><code>dfw</code>: Derivative of the (vector) activation function with respect to the        optional learnable weigths (w)         </li></ul><p><strong>Notes:</strong></p><ul><li>The output <code>size</code> of this layer is the same as those of the previous layers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn_default_layers.jl#L354-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.VectorFunctionLayer" href="#BetaML.Nn.VectorFunctionLayer"><code>BetaML.Nn.VectorFunctionLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>VectorFunctionLayer</p><p>Representation of a VectorFunction layer in the network. Vector function layer expects a vector activation function, i.e. a function taking the whole output of the previous layer an input rather than working on a single node as &quot;normal&quot; activation functions would do. Useful for example with the SoftMax function in classification or with the <code>pool1D</code> function to implement a &quot;pool&quot; layer in 1 dimensions. By default it is weightless, i.e. it doesn&#39;t apply any transformation to the output coming from the previous layer except the activation function. However, by passing the parameter <code>wsize</code> (a touple or array - tested only 1D) you can pass the learnable parameter to the activation function too. It is your responsability to be sure the activation function accept only X or also this  learnable array (as second argument).    The number of nodes in input must be set to the same as in the previous layer (and if you are using this for classification, to the number of classes, i.e. the <em>previous</em> layer must be set equal to the number of classes in the predictions).</p><p><strong>Fields:</strong></p><ul><li><code>w</code>:   Weigths (parameter) array passes as second argument to the activation        function (if not empty)</li><li><code>nₗ</code>:  Number of nodes in input (i.e. length of previous layer)</li><li><code>n</code>:   Number of nodes in output (automatically inferred in the constructor)</li><li><code>f</code>:   Activation function (vector)</li><li><code>dfx</code>: Derivative of the (vector) activation function with respect to the        layer inputs (x)</li><li><code>dfw</code>: Derivative of the (vector) activation function with respect to the        optional learnable weigths (w)         </li></ul><p><strong>Notes:</strong></p><ul><li>The output <code>size</code> of this layer is given by the size of the output function,</li></ul><p>that not necessarily is the same as the previous layers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn_default_layers.jl#L214-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{AbstractLayer}" href="#Base.size-Tuple{AbstractLayer}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(layer)</code></pre><p>Get the dimensions of the layers in terms of (dimensions in input , dimensions in output)</p><p><strong>Notes:</strong></p><ul><li>You need to use <code>import Base.size</code> before defining this function for your layer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L252-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Api.train!-Tuple{NN, Any, Any}" href="#BetaML.Api.train!-Tuple{NN, Any, Any}"><code>BetaML.Api.train!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>train!(nn,x,y;epochs,batchSize,sequential,optAlg,verbosity,cb)</p><p>Train a neural network with the given x,y data</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>:         Worker network</li><li><code>x</code>:          Training input to the network (records x dimensions)</li><li><code>y</code>:          Label input (records x dimensions)</li><li><code>epochs</code>:     Number of passages over the training set [def: <code>100</code>]</li><li><code>batchSize</code>:  Size of each individual batch [def: <code>min(size(x,1),32)</code>]</li><li><code>sequential</code>: Wether to run all data sequentially instead of random [def: <code>false</code>]</li><li><code>optAlg</code>:     The optimisation algorithm to update the gradient at each batch [def: <code>ADAM()</code>]</li><li><code>verbosity</code>:  A verbosity parameter for the trade off information / efficiency [def: <code>STD</code>]</li><li><code>cb</code>:         A callback to provide information. [def: <code>trainingInfo</code>]</li><li><code>rng</code>:        Random Number Generator (see <a href="Utils.html#BetaML.Utils.FIXEDSEED"><code>FIXEDSEED</code></a>) [deafult: <code>Random.GLOBAL_RNG</code>]</li></ul><p><strong>Return:</strong></p><ul><li>A named tuple with the following information<ul><li><code>epochs</code>: Number of epochs actually ran</li><li><code>ϵ_epochs</code>: The average error on each epoch (if <code>verbosity &gt; LOW</code>)</li><li><code>θ_epochs</code>: The parameters at each epoch (if <code>verbosity &gt; STD</code>)</li></ul></li></ul><p><strong>Notes:</strong></p><ul><li>Currently supported algorithms:<ul><li><code>SGD</code>, the classical (Stochastic) Gradient Descent optimiser</li><li><code>ADAM</code>,  an adaptive moment estimation optimiser</li></ul></li><li>Look at the individual optimisation algorithm (<code>?[Name OF THE ALGORITHM]</code>) for info on its parameter, e.g. <a href="Nn.html#BetaML.Nn.SGD"><code>?SGD</code></a> for the Stochastic Gradient Descent.</li><li>You can implement your own optimisation algorithm using a subtype of <code>OptimisationAlgorithm</code> and implementing its constructor and the update function <code>singleUpdate!(⋅)</code> (type <code>?singleUpdate!</code> for details).</li><li>You can implement your own callback function, altought the one provided by default is already pretty generic (its output depends on the <code>verbosity</code> parameter). See <a href="Nn.html#BetaML.Nn.trainingInfo-Tuple{Any, Any, Any}"><code>trainingInfo</code></a> for informations on the cb parameters.</li><li>Both the callback function and the <a href="Nn.html#BetaML.Nn.singleUpdate!-Tuple{Any, Any}"><code>singleUpdate!</code></a> function of the optimisation algorithm can be used to stop the training algorithm, respectively returning <code>true</code> or <code>stop=true</code>.</li><li>The verbosity can be set to any of <code>NONE</code>,<code>LOW</code>,<code>STD</code>,<code>HIGH</code>,<code>FULL</code>.</li><li>The update is done computing the average gradient for each batch and then calling <code>singleUpdate!</code> to let the optimisation algorithm perform the parameters update</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L578-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.backward-Tuple{AbstractLayer, Any, Any}" href="#BetaML.Nn.backward-Tuple{AbstractLayer, Any, Any}"><code>BetaML.Nn.backward</code></a> — <span class="docstring-category">Method</span></header><section><div><p>backward(layer,x,nextGradient)</p><p>Compute backpropagation for this layer</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>:        Worker layer</li><li><code>x</code>:            Input to the layer</li><li><code>nextGradient</code>: Derivative of the overal loss with respect to the input of the next layer (output of this layer)</li></ul><p><strong>Return:</strong></p><ul><li>The evaluated gradient of the loss with respect to this layer inputs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L185-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.buildNetwork-Tuple{Any, Any}" href="#BetaML.Nn.buildNetwork-Tuple{Any, Any}"><code>BetaML.Nn.buildNetwork</code></a> — <span class="docstring-category">Method</span></header><section><div><p>buildNetwork(layers,cf;dcf,name)</p><p>Instantiate a new Feedforward Neural Network</p><p>Parameters:</p><ul><li><code>layers</code>: Array of layers objects</li><li><code>cf</code>:     Cost function</li><li><code>dcf</code>:    Derivative of the cost function [def: <code>nothing</code>]</li><li><code>name</code>:   Name of the network [def: &quot;Neural Network&quot;]</li></ul><p><strong>Notes:</strong></p><ul><li>Even if the network ends with a single output note, the cost function and its derivative should always expect y and ŷ as column vectors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L300-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.forward-Tuple{AbstractLayer, Any}" href="#BetaML.Nn.forward-Tuple{AbstractLayer, Any}"><code>BetaML.Nn.forward</code></a> — <span class="docstring-category">Method</span></header><section><div><p>forward(layer,x)</p><p>Predict the output of the layer given the input</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>:  Worker layer</li><li><code>x</code>:      Input to the layer</li></ul><p><strong>Return:</strong></p><ul><li>An Array{T,1} of the prediction (even for a scalar)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L169-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.getGradient-Tuple{AbstractLayer, Any, Any}" href="#BetaML.Nn.getGradient-Tuple{AbstractLayer, Any, Any}"><code>BetaML.Nn.getGradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getGradient(layer,x,nextGradient)</p><p>Compute backpropagation for this layer</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>:        Worker layer</li><li><code>x</code>:            Input to the layer</li><li><code>nextGradient</code>: Derivative of the overaall loss with respect to the input of the next layer (output of this layer)</li></ul><p><strong>Return:</strong></p><ul><li>The evaluated gradient of the loss with respect to this layer&#39;s trainable parameters as tuple of matrices. It is up to you to decide how to organise this tuple, as long you are consistent with the <code>getParams()</code> and <code>setParams()</code> functions. Note that starting from BetaML 0.2.2 this tuple needs to be wrapped in its <code>Learnable</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L218-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.getGradient-Union{Tuple{T2}, Tuple{T}, Tuple{Any, AbstractMatrix{T}, AbstractMatrix{T2}}} where {T&lt;:Number, T2&lt;:Number}" href="#BetaML.Nn.getGradient-Union{Tuple{T2}, Tuple{T}, Tuple{Any, AbstractMatrix{T}, AbstractMatrix{T2}}} where {T&lt;:Number, T2&lt;:Number}"><code>BetaML.Nn.getGradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getGradient(nn,xbatch,ybatch)</p><p>Retrieve the current gradient of the weigthts (i.e. derivative of the cost with respect to the weigths)</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>:      Worker network</li><li><code>xbatch</code>:  Input to the network (n,d)</li><li><code>ybatch</code>:  Label input (n,d)</li></ul><p>#Notes:</p><ul><li>The output is a vector of tuples of each layer&#39;s input weigths and bias weigths</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L444-L456">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.getGradient-Union{Tuple{T2}, Tuple{T}, Tuple{NN, Union{AbstractVector{T}, T}, Union{AbstractVector{T2}, T2}}} where {T&lt;:Number, T2&lt;:Number}" href="#BetaML.Nn.getGradient-Union{Tuple{T2}, Tuple{T}, Tuple{NN, Union{AbstractVector{T}, T}, Union{AbstractVector{T2}, T2}}} where {T&lt;:Number, T2&lt;:Number}"><code>BetaML.Nn.getGradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getGradient(nn,x,y)</p><p>Retrieve the current gradient of the weigthts (i.e. derivative of the cost with respect to the weigths)</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li><li><code>x</code>:   Input to the network (d,1)</li><li><code>y</code>:   Label input (d,1)</li></ul><p>#Notes:</p><ul><li>The output is a vector of tuples of each layer&#39;s input weigths and bias weigths</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L394-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.getNParams-Tuple{AbstractLayer}" href="#BetaML.Nn.getNParams-Tuple{AbstractLayer}"><code>BetaML.Nn.getNParams</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getNParams(layer)</p><p>Return the number of parameters of a layer.</p><p>It doesn&#39;t need to be implemented by each layer type, as it uses getParams().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L264-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.getNParams-Tuple{NN}" href="#BetaML.Nn.getNParams-Tuple{NN}"><code>BetaML.Nn.getNParams</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getNParams(nn) - Return the number of trainable parameters of the neural network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.getParams-Tuple{AbstractLayer}" href="#BetaML.Nn.getParams-Tuple{AbstractLayer}"><code>BetaML.Nn.getParams</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getParams(layer)</p><p>Get the layers current value of its trainable parameters</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>:  Worker layer</li></ul><p><strong>Return:</strong></p><ul><li>The current value of the layer&#39;s trainable parameters as tuple of matrices. It is up to you to decide how to organise this tuple, as long you are consistent with the <code>getGradient()</code> and <code>setParams()</code> functions. Note that starting from BetaML 0.2.2 this tuple needs to be wrapped in its <code>Learnable</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L203-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.getParams-Tuple{NN}" href="#BetaML.Nn.getParams-Tuple{NN}"><code>BetaML.Nn.getParams</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getParams(nn)</p><p>Retrieve current weigthts</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li></ul><p><strong>Notes:</strong></p><ul><li>The output is a vector of tuples of each layer&#39;s input weigths and bias weigths</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L378-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.initOptAlg!-Tuple{ADAM}" href="#BetaML.Nn.initOptAlg!-Tuple{ADAM}"><code>BetaML.Nn.initOptAlg!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>initOptAlg!(optAlg::ADAM;θ,batchSize,x,y,rng)</p><p>Initialize the ADAM algorithm with the parameters m and v as zeros and check parameter bounds</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn_default_optalgs.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.initOptAlg!-Tuple{BetaML.Nn.OptimisationAlgorithm}" href="#BetaML.Nn.initOptAlg!-Tuple{BetaML.Nn.OptimisationAlgorithm}"><code>BetaML.Nn.initOptAlg!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>initOptAlg!(optAlg;θ,batchSize,x,y)</p><p>Initialize the optimisation algorithm</p><p><strong>Parameters:</strong></p><ul><li><code>optAlg</code>:    The Optimisation algorithm to use</li><li><code>θ</code>:         Current parameters</li><li><code>batchSize</code>:    The size of the batch</li><li><code>x</code>:   The training (input) data</li><li><code>y</code>:   The training &quot;labels&quot; to match</li><li><code>rng</code>: Random Number Generator (see <a href="Utils.html#BetaML.Utils.FIXEDSEED"><code>FIXEDSEED</code></a>) [deafult: <code>Random.GLOBAL_RNG</code>]</li></ul><p><strong>Notes:</strong></p><ul><li>Only a few optimizers need this function and consequently ovverride it. By default it does nothing, so if you want write your own optimizer and don&#39;t need to initialise it, you don&#39;t have to override this method</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L712-L727">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.loss-Tuple{NN, Any, Any}" href="#BetaML.Nn.loss-Tuple{NN, Any, Any}"><code>BetaML.Nn.loss</code></a> — <span class="docstring-category">Method</span></header><section><div><p>loss(fnn,x,y)</p><p>Compute avg. network loss on a test set (or a single (1 × d) data point)</p><p><strong>Parameters:</strong></p><ul><li><code>fnn</code>: Worker network</li><li><code>x</code>:   Input to the network (n) or (n x d)</li><li><code>y</code>:   Label input (n) or (n x d)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L355-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.setParams!-Tuple{AbstractLayer, Any}" href="#BetaML.Nn.setParams!-Tuple{AbstractLayer, Any}"><code>BetaML.Nn.setParams!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> setParams!(layer,w)</code></pre><p>Set the trainable parameters of the layer with the given values</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>: Worker layer</li><li><code>w</code>:     The new parameters to set (Learnable)</li></ul><p><strong>Notes:</strong></p><ul><li>The format of the tuple wrapped by Learnable must be consistent with those of the <code>getParams()</code> and <code>getGradient()</code> functions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L235-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.setParams!-Tuple{NN, Any}" href="#BetaML.Nn.setParams!-Tuple{NN, Any}"><code>BetaML.Nn.setParams!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>setParams!(nn,w)</p><p>Update weigths of the network</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li><li><code>w</code>:  The new weights to set</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L473-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.show-Tuple{NN}" href="#BetaML.Nn.show-Tuple{NN}"><code>BetaML.Nn.show</code></a> — <span class="docstring-category">Method</span></header><section><div><p>show(nn)</p><p>Print a representation of the Neural Network (layers, dimensions..)</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L491-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.singleUpdate!-Tuple{Any, Any}" href="#BetaML.Nn.singleUpdate!-Tuple{Any, Any}"><code>BetaML.Nn.singleUpdate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>singleUpdate!(θ,▽;nEpoch,nBatch,batchSize,xbatch,ybatch,optAlg)</p><p>Perform the parameters update based on the average batch gradient.</p><p><strong>Parameters:</strong></p><ul><li><code>θ</code>:         Current parameters</li><li><code>▽</code>:         Average gradient of the batch</li><li><code>nEpoch</code>:    Count of current epoch</li><li><code>nBatch</code>:    Count of current batch</li><li><code>nBatches</code>:  Number of batches per epoch</li><li><code>xbatch</code>:    Data associated to the current batch</li><li><code>ybatch</code>:    Labels associated to the current batch</li><li><code>optAlg</code>:    The Optimisation algorithm to use for the update</li></ul><p><strong>Notes:</strong></p><ul><li>This function is overridden so that each optimisation algorithm implement their</li></ul><p>own version</p><ul><li>Most parameters are not used by any optimisation algorithm. They are provided</li></ul><p>to support the largest possible class of optimisation algorithms</p><ul><li>Some optimisation algorithms may change their internal structure in this function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L682-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.trainingInfo-Tuple{Any, Any, Any}" href="#BetaML.Nn.trainingInfo-Tuple{Any, Any, Any}"><code>BetaML.Nn.trainingInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><p>trainingInfo(nn,x,y;n,batchSize,epochs,verbosity,nEpoch,nBatch)</p><p>Default callback funtion to display information during training, depending on the verbosity level</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li><li><code>x</code>:  Batch input to the network (batchSize,d)</li><li><code>y</code>:  Batch label input (batchSize,d)</li><li><code>n</code>: Size of the full training set</li><li><code>nBatches</code> : Number of baches per epoch</li><li><code>epochs</code>: Number of epochs defined for the training</li><li><code>verbosity</code>: Verbosity level defined for the training (NONE,LOW,STD,HIGH,FULL)</li><li><code>nEpoch</code>: Counter of the current epoch</li><li><code>nBatch</code>: Counter of the current batch</li></ul><p>#Notes:</p><ul><li>Reporting of the error (loss of the network) is expensive. Use <code>verbosity=NONE</code> for better performances</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/a544b994e9783892a4df5f1e34a41882d63149cb/src/Nn/Nn.jl#L542-L560">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Trees.html">« Trees</a><a class="docs-footer-nextpage" href="Clustering.html">Clustering »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Wednesday 27 July 2022 13:10">Wednesday 27 July 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
