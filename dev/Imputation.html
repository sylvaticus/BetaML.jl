<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Imputation · BetaML.jl Documentation</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-JYKX8QY5JW"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-JYKX8QY5JW', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">BetaML.jl Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Index</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="tutorials/Betaml_tutorial_getting_started.html">Getting started</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Regression - bike sharing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tutorials/Regression - bike sharing/betaml_tutorial_regression_sharingBikes.html">A regression task: the prediction of  bike  sharing demand</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Classification - cars</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tutorials/Classification - cars/betaml_tutorial_classification_cars.html">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Clustering - Iris</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tutorials/Clustering - Iris/betaml_tutorial_cluster_iris.html">A clustering task: the prediction of  plant species from floreal measures (the iris dataset)</a></li></ul></li></ul></li><li><span class="tocitem">API (Reference manual)</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">API V2 (current testing)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="Api_v2_user.html">Introduction for user</a></li><li><a class="tocitem" href="Api_v2_developer.html">For developers</a></li></ul></li><li><a class="tocitem" href="Perceptron.html">Perceptron</a></li><li><a class="tocitem" href="Trees.html">Trees</a></li><li><a class="tocitem" href="Nn.html">Nn</a></li><li><a class="tocitem" href="Clustering.html">Clustering</a></li><li><a class="tocitem" href="GMM.html">GMM</a></li><li class="is-active"><a class="tocitem" href="Imputation.html">Imputation</a><ul class="internal"><li><a class="tocitem" href="#Module-Index"><span>Module Index</span></a></li><li><a class="tocitem" href="#Detailed-API"><span>Detailed API</span></a></li></ul></li><li><a class="tocitem" href="Utils.html">Utils</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API (Reference manual)</a></li><li class="is-active"><a href="Imputation.html">Imputation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Imputation.html">Imputation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sylvaticus/BetaML.jl/blob/master/docs/src/Imputation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="imputation_module"><a class="docs-heading-anchor" href="#imputation_module">The BetaML.Imputation Module</a><a id="imputation_module-1"></a><a class="docs-heading-anchor-permalink" href="#imputation_module" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="BetaML.Imputation" href="#BetaML.Imputation"><code>BetaML.Imputation</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Imputation module</code></pre><p>Provide various imputation methods for missing data. Note that the interpretation of &quot;missing&quot; can be very wide. For example, reccomendation systems / collaborative filtering (e.g. suggestion of the film to watch) can well be representated as a missing data to impute problem.</p><p>Using the original &quot;V1&quot; API:</p><ul><li><a href="Imputation.html#BetaML.Imputation.predictMissing"><code>predictMissing</code></a>: Impute data using a Generative (Gaussian) Mixture Model (good trade off)</li></ul><p>Using the v2 API (experimental):</p><ul><li><a href="Imputation.html#BetaML.Imputation.MeanImputer"><code>MeanImputer</code></a>: Simple imputator using the features or the records means, with optional record normalisation (fastest)</li><li><a href="Imputation.html#BetaML.Imputation.GMMImputer"><code>GMMImputer</code></a>: Impute data using a Generative (Gaussian) Mixture Model (good trade off)</li><li><a href="Imputation.html#BetaML.Imputation.RFImputer"><code>RFImputer</code></a>: Impute missing data using Random Forests, with optional replicable multiple imputations (most accurate).</li><li><a href="@ref"><code>GenericImputer</code></a>: Impute missing data using a vector (one per column) of arbitrary learning models (classifiers/regressors) that implement <code>m = Model([options])</code>, <code>train!(m,X,Y)</code> and <code>predict(m,X)</code>.</li></ul><p>Imputations for all these models can be optained by running <code>mod = ImputatorModel([options])</code>, <code>fit!(mod,X)</code>. The data with the missing values imputed can then be obtained with <code>predict(mod)</code>. Use<code>info(m::Imputer)</code> to retrieve further information concerning the imputation. Trained models can be also used to impute missing values in new data with <code>predict(mox,xNew)</code>. Note that if multiple imputations are run (for the supporting imputators) <code>predict()</code> will return a vector of predictions rather than a single one`.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using Statistics, BetaML

julia&gt; X            = [2 missing 10; 2000 4000 1000; 2000 4000 10000; 3 5 12 ; 4 8 20; 1 2 5]
6×3 Matrix{Union{Missing, Int64}}:
    2      missing     10
 2000  4000          1000
 2000  4000         10000
    3     5            12
    4     8            20
    1     2             5

julia&gt; mod          = RFImputer(multipleImputations=10,  rng=copy(FIXEDRNG));

julia&gt; fit!(mod,X)
true

julia&gt; vals         = predict(mod)
10-element Vector{Matrix{Union{Missing, Int64}}}:
 [2 3 10; 2000 4000 1000; … ; 4 8 20; 1 2 5]
 [2 4 10; 2000 4000 1000; … ; 4 8 20; 1 2 5]
 [2 4 10; 2000 4000 1000; … ; 4 8 20; 1 2 5]
 [2 136 10; 2000 4000 1000; … ; 4 8 20; 1 2 5]
 [2 137 10; 2000 4000 1000; … ; 4 8 20; 1 2 5]
 [2 4 10; 2000 4000 1000; … ; 4 8 20; 1 2 5]
 [2 4 10; 2000 4000 1000; … ; 4 8 20; 1 2 5]
 [2 4 10; 2000 4000 1000; … ; 4 8 20; 1 2 5]
 [2 137 10; 2000 4000 1000; … ; 4 8 20; 1 2 5]
 [2 137 10; 2000 4000 1000; … ; 4 8 20; 1 2 5]

julia&gt; nR,nC        = size(vals[1])
(6, 3)

julia&gt; medianValues = [median([v[r,c] for v in vals]) for r in 1:nR, c in 1:nC]
6×3 Matrix{Float64}:
    2.0     4.0     10.0
 2000.0  4000.0   1000.0
 2000.0  4000.0  10000.0
    3.0     5.0     12.0
    4.0     8.0     20.0
    1.0     2.0      5.0

julia&gt; infos        = info(mod);

julia&gt; infos[:nImputedValues]
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L12-L82">source</a></section></article><h2 id="Module-Index"><a class="docs-heading-anchor" href="#Module-Index">Module Index</a><a id="Module-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Index" title="Permalink"></a></h2><ul><li><a href="Imputation.html#BetaML.Imputation.GMMImputer"><code>BetaML.Imputation.GMMImputer</code></a></li><li><a href="Imputation.html#BetaML.Imputation.GeneralImputer"><code>BetaML.Imputation.GeneralImputer</code></a></li><li><a href="Imputation.html#BetaML.Imputation.GeneralImputerHyperParametersSet"><code>BetaML.Imputation.GeneralImputerHyperParametersSet</code></a></li><li><a href="Imputation.html#BetaML.Imputation.MeanImputer"><code>BetaML.Imputation.MeanImputer</code></a></li><li><a href="Imputation.html#BetaML.Imputation.RFImputer"><code>BetaML.Imputation.RFImputer</code></a></li><li><a href="Imputation.html#BetaML.Imputation.RFImputerHyperParametersSet"><code>BetaML.Imputation.RFImputerHyperParametersSet</code></a></li><li><a href="Imputation.html#BetaML.Imputation.predictMissing"><code>BetaML.Imputation.predictMissing</code></a></li></ul><h2 id="Detailed-API"><a class="docs-heading-anchor" href="#Detailed-API">Detailed API</a><a id="Detailed-API-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BetaML.Imputation.GMMImputer" href="#BetaML.Imputation.GMMImputer"><code>BetaML.Imputation.GMMImputer</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong><code>GMMImputer</code></strong></p><p>Missing data imputer that uses a Generated (Gaussian) Mixture Model.</p><p>For the parameters (<code>nClasses</code>,<code>mixtures</code>,..) see  <a href="@ref"><code>GMMImputerLearnableParameters</code></a>.</p><p><strong>Limitations:</strong></p><ul><li>data must be numerical</li><li>the resulted matrix is a Matrix{Float64}</li><li>currently the Mixtures available do not support random initialisation for missing imputation, and the rest of the algorithm (we use the Expectation-Maximisation) is deterministic, so there is no random component involved (i.e. no multiple imputations)    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L314-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Imputation.GeneralImputer" href="#BetaML.Imputation.GeneralImputer"><code>BetaML.Imputation.GeneralImputer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralImputer</code></pre><p>Impute missing data using any regressor/classifier (not necessarily from BetaML) that implements <code>m=Model([options])</code>, <code>fit!(m,X,Y)</code> and <code>predict(m,X)</code></p><p>See <a href="Imputation.html#BetaML.Imputation.GeneralImputerHyperParametersSet"><code>GeneralImputerHyperParametersSet</code></a> for the hyper-parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L768-L775">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Imputation.GeneralImputerHyperParametersSet" href="#BetaML.Imputation.GeneralImputerHyperParametersSet"><code>BetaML.Imputation.GeneralImputerHyperParametersSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct GeneralImputerHyperParametersSet &lt;: BetaMLHyperParametersSet</code></pre><p>Hyperparameters for GeneralImputer</p><p><strong>Parameters:</strong></p><ul><li><p><code>models</code></p><p>Specify a regressor or classier model per column. Default to random forests.</p></li><li><p><code>recursivePassages</code></p><p>Define the times to go trough the various columns to impute their data. Useful when there are data to impute on multiple columns. The order of the first passage is given by the decreasing number of missing values per column, the other passages are random [default: <code>1</code>].</p></li><li><p><code>multipleImputations</code></p><p>Determine the number of independent imputation of the whole dataset to make. Note that while independent, the imputations share the same random number generator (RNG).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L746">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Imputation.MeanImputer" href="#BetaML.Imputation.MeanImputer"><code>BetaML.Imputation.MeanImputer</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong><code>MeanImputer</code></strong></p><p>Simple imputer using the feature (column) mean, optionally normalised by l-norms of the records (rows)</p><p><strong>Parameters:</strong></p><ul><li><code>norm</code>: Normalise the feature mean by l-<code>norm</code> norm of the records [default: <code>nothing</code>]. Use it (e.g. <code>norm=1</code> to use the l-1 norm) if the records are highly heterogeneus (e.g. quantity exports of different countries).  </li></ul><p><strong>Limitations:</strong></p><ul><li>data must be numerical</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L190-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Imputation.RFImputer" href="#BetaML.Imputation.RFImputer"><code>BetaML.Imputation.RFImputer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RFImputer</code></pre><p>Impute missing data using Random Forests, with optional replicable multiple imputations. </p><p>See <a href="Imputation.html#BetaML.Imputation.RFImputerHyperParametersSet"><code>RFImputerHyperParametersSet</code></a> and <a href="@ref"><code>RFHyperParametersSet</code></a></p><p><strong>Notes:</strong></p><ul><li>Given a certain RNG and its status (e.g. <code>RFImputer(...,rng=StableRNG(FIXEDSEED))</code>), the algorithm is completely deterministic, i.e. replicable. </li><li>The algorithm accepts virtually any kind of data, sortable or not</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L486-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Imputation.RFImputerHyperParametersSet" href="#BetaML.Imputation.RFImputerHyperParametersSet"><code>BetaML.Imputation.RFImputerHyperParametersSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong><code>RFImputerHyperParametersSet</code></strong></p><p>Hyperparameters for RFImputer</p><p>#Parameters</p><ul><li>For the underlying random forest algorithm parameters (<code>nTrees</code>,<code>maxDepth</code>,<code>minGain</code>,<code>minRecords</code>,<code>maxFeatures:</code>,<code>splittingCriterion</code>,<code>β</code>,<code>initStrategy</code>, <code>oob</code> and <code>rng</code>) see <a href="@ref"><code>RFHyperParametersSet</code></a> for the specific RF algorithm parameters</li><li><code>forcedCategoricalCols</code>: specify the positions of the integer columns to treat as categorical instead of cardinal. [Default: empty vector (all numerical cols are treated as cardinal by default and the others as categorical)]</li><li><code>recursivePassages</code>: Define the times to go trough the various columns to impute their data. Useful when there are data to impute on multiple columns. The order of the first passage is given by the decreasing number of missing values per column, the other passages are random [default: <code>1</code>].</li><li><code>multipleImputations</code>: Determine the number of independent imputation of the whole dataset to make. Note that while independent, the imputations share the same random number generator (RNG).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L461-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Api.fit!-Tuple{GMMImputer, Any}" href="#BetaML.Api.fit!-Tuple{GMMImputer, Any}"><code>BetaML.Api.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(imputer::GMMImputer,X)</code></pre><p>Fit a matrix with missing data using <a href="Imputation.html#BetaML.Imputation.GMMImputer"><code>GMMImputer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L361-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Api.fit!-Tuple{GeneralImputer, Any}" href="#BetaML.Api.fit!-Tuple{GeneralImputer, Any}"><code>BetaML.Api.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(imputer::GenralImputer,X)</code></pre><p>Fit a matrix with missing data using <a href="Imputation.html#BetaML.Imputation.GeneralImputer"><code>GeneralImputer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L812-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Api.fit!-Tuple{MeanImputer, Any}" href="#BetaML.Api.fit!-Tuple{MeanImputer, Any}"><code>BetaML.Api.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(imputer::MeanImputer,X)</code></pre><p>Fit a matrix with missing data using <a href="Imputation.html#BetaML.Imputation.MeanImputer"><code>MeanImputer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Api.fit!-Tuple{RFImputer, Any}" href="#BetaML.Api.fit!-Tuple{RFImputer, Any}"><code>BetaML.Api.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(imputer::RFImputer,X)</code></pre><p>Fit a matrix with missing data using <a href="Imputation.html#BetaML.Imputation.RFImputer"><code>RFImputer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L534-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Api.predict-Tuple{GeneralImputer, Any}" href="#BetaML.Api.predict-Tuple{GeneralImputer, Any}"><code>BetaML.Api.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(m::GeneralImputer, [X])</code></pre><p>Return the data with the missing values replaced with the imputed ones using <a href="Imputation.html#BetaML.Imputation.RFImputer"><code>RFImputer</code></a>. If <code>multipleImputations</code> was set &gt;1 this is a vector of matrices (the individual imputations) instead of a single matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L926-L930">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Api.predict-Tuple{MeanImputer, Any}" href="#BetaML.Api.predict-Tuple{MeanImputer, Any}"><code>BetaML.Api.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(m::MeanImputer, X)</code></pre><p>Return the data with the missing values replaced with the imputed ones using <a href="Imputation.html#BetaML.Imputation.MeanImputer"><code>MeanImputer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L265-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Api.predict-Tuple{RFImputer, Any}" href="#BetaML.Api.predict-Tuple{RFImputer, Any}"><code>BetaML.Api.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(m::RFImputer, X)</code></pre><p>Return the data with the missing values replaced with the imputed ones using <a href="Imputation.html#BetaML.Imputation.RFImputer"><code>RFImputer</code></a>. If <code>multipleImputations</code> was set &gt;1 this is a vector of matrices (the individual imputations) instead of a single matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L671-L675">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Imputation.predictMissing" href="#BetaML.Imputation.predictMissing"><code>BetaML.Imputation.predictMissing</code></a> — <span class="docstring-category">Function</span></header><section><div><p>predictMissing(X,K;p₀,mixtures,tol,verbosity,minVariance,minCovariance)</p><p>Note: This is the OLD API. See <a href="@ref"><code>GMMClusterer</code></a> for the V2 API.</p><p>Fill missing entries in a sparse matrix (i.e. perform a &quot;matrix completion&quot;) assuming an underlying Gaussian Mixture probabilistic Model (GMM) and implementing an Expectation-Maximisation algorithm.</p><p>While the name of the function is <code>predictMissing</code>, the function can be also used for system reccomendation / collaborative filtering and GMM-based regressions. The advantage over traditional algorithms as k-nearest neighbors (KNN) is that GMM can &quot;detect&quot; the hidden structure of the observed data, where some observation can be similar to a certain pool of other observvations for a certain characteristic, but similar to an other pool of observations for other characteristics.</p><p>Implemented in the log-domain for better numerical accuracy with many dimensions.</p><p><strong>Parameters:</strong></p><ul><li><code>X</code>  :           A (N x D) sparse matrix of data to fill according to a GMM model</li><li><code>K</code>  :           Number of mixtures (latent classes) to consider [def: 3]</li><li><code>p₀</code> :           Initial probabilities of the categorical distribution (K x 1) [default: <code>[]</code>]</li><li><code>mixtures</code>:      An array (of length K) of the mixture to employ (see notes) [def: <code>[DiagonalGaussian() for i in 1:K]</code>]</li><li><code>tol</code>:           Tolerance to stop the algorithm [default: 10^(-6)]</li><li><code>verbosity</code>:     A verbosity parameter regulating the information messages frequency [def: <code>STD</code>]</li><li><code>minVariance</code>:   Minimum variance for the mixtures [default: 0.05]</li><li><code>minCovariance</code>: Minimum covariance for the mixtures with full covariance matrix [default: 0]. This should be set different than minVariance (see notes).</li><li><code>initStrategy</code>:  Mixture initialisation algorithm [def: <code>grid</code>]</li><li><code>maxIter</code>:       Maximum number of iterations [def: <code>typemax(Int64)</code>, i.e. ∞]</li><li><code>rng</code>:           Random Number Generator (see <a href="@ref"><code>FIXEDSEED</code></a>) [deafult: <code>Random.GLOBAL_RNG</code>]</li></ul><p><strong>Returns:</strong></p><ul><li>A named touple of:</li><li><code>̂X̂</code>    : The Filled Matrix of size (N x D)</li><li><code>nFill</code>: The number of items filled</li><li><code>lL</code>   : The log-likelihood (without considering the last mixture optimisation)</li><li><code>BIC</code> :  The Bayesian Information Criterion (lower is better)</li><li><code>AIC</code> :  The Akaike Information Criterion (lower is better)</li></ul><p><strong>Notes:</strong></p><ul><li>The mixtures currently implemented are <code>SphericalGaussian(μ,σ²)</code>,<code>DiagonalGaussian(μ,σ²)</code> and <code>FullGaussian(μ,σ²)</code></li><li>For <code>initStrategy</code>, look at the documentation of <code>initMixtures!</code> for the mixture you want. The provided gaussian mixtures support <code>grid</code>, <code>kmeans</code> or <code>given</code>. <code>grid</code> is faster, but <code>kmeans</code> often provides better results.</li><li>The algorithm requires to specify a number of &quot;latent classes&quot; (mlixtures) to divide the dataset into. If there isn&#39;t any prior domain specific knowledge on this point one can test sevaral <code>k</code> and verify which one minimise the <code>BIC</code> or <code>AIC</code> criteria.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">julia&gt;  cFOut = predictMissing([1 10.5;1.5 missing; 1.8 8; 1.7 15; 3.2 40; missing missing; 3.3 38; missing -2.3; 5.2 -2.4],3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation.jl#L106-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.transform-Tuple{MissingImputator, Any, Any}" href="#MLJModelInterface.transform-Tuple{MissingImputator, Any, Any}"><code>MLJModelInterface.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><p>transform(m::MissingImputator, fitResults, X) - Given a trained imputator model fill the missing data of some new observations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/7b849e7badbd68fbf8709624aab6b112f739e505/src/Imputation/Imputation_MLJ.jl#L226">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="GMM.html">« GMM</a><a class="docs-footer-nextpage" href="Utils.html">Utils »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 26 August 2022 09:38">Friday 26 August 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
