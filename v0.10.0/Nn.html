<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nn · BetaML.jl Documentation</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-JYKX8QY5JW"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-JYKX8QY5JW', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">BetaML.jl Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Index</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="tutorials/Betaml_tutorial_getting_started.html">Getting started</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Classification - cars</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tutorials/Classification - cars/betaml_tutorial_classification_cars.html">A classification task when labels are known - determining the country of origin of cars given the cars characteristics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Regression - bike sharing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tutorials/Regression - bike sharing/betaml_tutorial_regression_sharingBikes.html">A regression task: the prediction of  bike  sharing demand</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Clustering - Iris</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="tutorials/Clustering - Iris/betaml_tutorial_cluster_iris.html">A clustering task: the prediction of  plant species from floreal measures (the iris dataset)</a></li></ul></li></ul></li><li><span class="tocitem">API (Reference manual)</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">API V2 (current)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="Api_v2_user.html">Introduction for user</a></li><li><input class="collapse-toggle" id="menuitem-3-1-2" type="checkbox"/><label class="tocitem" for="menuitem-3-1-2"><span class="docs-label">For developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="Api_v2_developer.html">API implementation</a></li><li><a class="tocitem" href="StyleGuide_templates.html">Style guide</a></li></ul></li><li><a class="tocitem" href="Api.html">The Api module</a></li></ul></li><li><a class="tocitem" href="Perceptron.html">Perceptron</a></li><li><a class="tocitem" href="Trees.html">Trees</a></li><li class="is-active"><a class="tocitem" href="Nn.html">Nn</a><ul class="internal"><li><a class="tocitem" href="#Module-Index"><span>Module Index</span></a></li><li><a class="tocitem" href="#Detailed-API"><span>Detailed API</span></a></li></ul></li><li><a class="tocitem" href="Clustering.html">Clustering</a></li><li><a class="tocitem" href="GMM.html">GMM</a></li><li><a class="tocitem" href="Imputation.html">Imputation</a></li><li><a class="tocitem" href="Utils.html">Utils</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API (Reference manual)</a></li><li class="is-active"><a href="Nn.html">Nn</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Nn.html">Nn</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sylvaticus/BetaML.jl/blob/master/docs/src/Nn.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="nn_module"><a class="docs-heading-anchor" href="#nn_module">The BetaML.Nn Module</a><a id="nn_module-1"></a><a class="docs-heading-anchor-permalink" href="#nn_module" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn" href="#BetaML.Nn"><code>BetaML.Nn</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">BetaML.Nn module</code></pre><p>Implement the functionality required to define an artificial Neural Network, train it with data, forecast data and assess its performances.</p><p>Common type of layers and optimisation algorithms are already provided, but you can define your own ones subclassing respectively the <code>AbstractLayer</code> and <code>OptimisationAlgorithm</code> abstract types.</p><p>The module provide the following types or functions. Use <code>?[type or function]</code> to access their full signature and detailed documentation:</p><p><strong>Model definition:</strong></p><ul><li><code>DenseLayer</code>: Classical feed-forward layer with user-defined activation function</li><li><code>DenseNoBiasLayer</code>: Classical layer without the bias parameter</li><li><code>VectorFunctionLayer</code>: Parameterless layer whose activation function run over the ensable of its nodes rather than on each one individually</li><li><code>NeuralNetworkEstimator</code>: Build the chained network and define a cost function</li></ul><p>Each layer can use a default activation function, one of the functions provided in the <code>Utils</code> module (<code>relu</code>, <code>tanh</code>, <code>softmax</code>,...) or you can specify your own function. The derivative of the activation function can be optionally be provided, in such case training will be quicker, altought this difference tends to vanish with bigger datasets. You can alternativly implement your own layer defining a new type as subtype of the abstract type <code>AbstractLayer</code>. Each user-implemented layer must define the following methods:</p><ul><li>A suitable constructor</li><li><code>forward(layer,x)</code></li><li><code>backward(layer,x,next_gradient)</code></li><li><code>get_params(layer)</code></li><li><code>get_gradient(layer,x,next_gradient)</code></li><li><code>set_params!(layer,w)</code></li><li><code>size(layer)</code></li></ul><p><strong>Model fitting:</strong></p><ul><li><code>fit!(nn,X,Y)</code>:  fitting function</li><li><code>fitting_info(nn)</code>: Default callback function during fitting</li><li><code>SGD</code>:  The classical optimisation algorithm</li><li><code>ADAM</code>: A faster moment-based optimisation algorithm </li></ul><p>To define your own optimisation algorithm define a subtype of <code>OptimisationAlgorithm</code> and implement the function <code>single_update!(θ,▽;opt_alg)</code> and eventually <code>init_optalg!(⋅)</code> specific for it.</p><p><strong>Model predictions and assessment:</strong></p><ul><li><code>predict(nn)</code> or <code>predict(nn,X)</code>: Return the output given the data</li></ul><p>While high-level functions operating on the dataset expect it to be in the standard format (n<em>records × n</em>dimensions matrices) it is customary to represent the chain of a neural network as a flow of column vectors, so all low-level operations (operating on a single datapoint) expect both the input and the output as a column vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L4-L47">source</a></section></article><h2 id="Module-Index"><a class="docs-heading-anchor" href="#Module-Index">Module Index</a><a id="Module-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Index" title="Permalink"></a></h2><ul><li><a href="Nn.html#BetaML.Nn.ADAM"><code>BetaML.Nn.ADAM</code></a></li><li><a href="Nn.html#BetaML.Nn.ConvLayer"><code>BetaML.Nn.ConvLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.ConvLayer-Tuple{Any, Any, Any}"><code>BetaML.Nn.ConvLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.DenseLayer"><code>BetaML.Nn.DenseLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.DenseNoBiasLayer"><code>BetaML.Nn.DenseNoBiasLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.Learnable"><code>BetaML.Nn.Learnable</code></a></li><li><a href="Nn.html#BetaML.Nn.MultitargetNeuralNetworkRegressor"><code>BetaML.Nn.MultitargetNeuralNetworkRegressor</code></a></li><li><a href="Nn.html#BetaML.Nn.NNHyperParametersSet"><code>BetaML.Nn.NNHyperParametersSet</code></a></li><li><a href="Nn.html#BetaML.Nn.NeuralNetworkClassifier"><code>BetaML.Nn.NeuralNetworkClassifier</code></a></li><li><a href="Nn.html#BetaML.Nn.NeuralNetworkEstimator"><code>BetaML.Nn.NeuralNetworkEstimator</code></a></li><li><a href="Nn.html#BetaML.Nn.NeuralNetworkEstimatorOptionsSet"><code>BetaML.Nn.NeuralNetworkEstimatorOptionsSet</code></a></li><li><a href="Nn.html#BetaML.Nn.NeuralNetworkRegressor"><code>BetaML.Nn.NeuralNetworkRegressor</code></a></li><li><a href="Nn.html#BetaML.Nn.PoolingLayer"><code>BetaML.Nn.PoolingLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.PoolingLayer-Tuple{Any, Any}"><code>BetaML.Nn.PoolingLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.ReshaperLayer"><code>BetaML.Nn.ReshaperLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.SGD"><code>BetaML.Nn.SGD</code></a></li><li><a href="Nn.html#BetaML.Nn.ScalarFunctionLayer"><code>BetaML.Nn.ScalarFunctionLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.VectorFunctionLayer"><code>BetaML.Nn.VectorFunctionLayer</code></a></li><li><a href="Nn.html#BetaML.Nn.backward-Tuple{AbstractLayer, Any, Any}"><code>BetaML.Nn.backward</code></a></li><li><a href="Nn.html#BetaML.Nn.fitting_info-Tuple{Any, Any, Any}"><code>BetaML.Nn.fitting_info</code></a></li><li><a href="Nn.html#BetaML.Nn.forward-Tuple{ConvLayer, Any}"><code>BetaML.Nn.forward</code></a></li><li><a href="Nn.html#BetaML.Nn.forward-Tuple{PoolingLayer, Any}"><code>BetaML.Nn.forward</code></a></li><li><a href="Nn.html#BetaML.Nn.forward-Tuple{AbstractLayer, Any}"><code>BetaML.Nn.forward</code></a></li><li><a href="Nn.html#BetaML.Nn.get_gradient-Union{Tuple{N2}, Tuple{N1}, Tuple{T2}, Tuple{T}, Tuple{BetaML.Nn.NN, Union{AbstractArray{T, N1}, T}, Union{AbstractArray{T2, N2}, T2}}} where {T&lt;:Number, T2&lt;:Number, N1, N2}"><code>BetaML.Nn.get_gradient</code></a></li><li><a href="Nn.html#BetaML.Nn.get_gradient-Tuple{AbstractLayer, Any, Any}"><code>BetaML.Nn.get_gradient</code></a></li><li><a href="Nn.html#BetaML.Nn.get_params-Tuple{BetaML.Nn.NN}"><code>BetaML.Nn.get_params</code></a></li><li><a href="Nn.html#BetaML.Nn.get_params-Tuple{AbstractLayer}"><code>BetaML.Nn.get_params</code></a></li><li><a href="Nn.html#BetaML.Nn.init_optalg!-Tuple{BetaML.Nn.OptimisationAlgorithm}"><code>BetaML.Nn.init_optalg!</code></a></li><li><a href="Nn.html#BetaML.Nn.init_optalg!-Tuple{ADAM}"><code>BetaML.Nn.init_optalg!</code></a></li><li><a href="Nn.html#BetaML.Nn.preprocess!-Tuple{AbstractLayer}"><code>BetaML.Nn.preprocess!</code></a></li><li><a href="Nn.html#BetaML.Nn.set_params!-Tuple{BetaML.Nn.NN, Any}"><code>BetaML.Nn.set_params!</code></a></li><li><a href="Nn.html#BetaML.Nn.set_params!-Tuple{AbstractLayer, Any}"><code>BetaML.Nn.set_params!</code></a></li><li><a href="Nn.html#BetaML.Nn.single_update!-Tuple{Any, Any}"><code>BetaML.Nn.single_update!</code></a></li></ul><h2 id="Detailed-API"><a class="docs-heading-anchor" href="#Detailed-API">Detailed API</a><a id="Detailed-API-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.ADAM" href="#BetaML.Nn.ADAM"><code>BetaML.Nn.ADAM</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ADAM(;η, λ, β₁, β₂, ϵ)</p><p>The <a href="https://arxiv.org/pdf/1412.6980.pdf">ADAM</a> algorithm, an adaptive moment estimation optimiser.</p><p><strong>Fields:</strong></p><ul><li><code>η</code>:  Learning rate (stepsize, α in the paper), as a function of the current epoch [def: t -&gt; 0.001 (i.e. fixed)]</li><li><code>λ</code>:  Multiplicative constant to the learning rate [def: 1]</li><li><code>β₁</code>: Exponential decay rate for the first moment estimate [range: ∈ [0,1], def: 0.9]</li><li><code>β₂</code>: Exponential decay rate for the second moment estimate [range: ∈ [0,1], def: 0.999]</li><li><code>ϵ</code>:  Epsilon value to avoid division by zero [def: 10^-8]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn_default_optalgs.jl#L47-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.ConvLayer" href="#BetaML.Nn.ConvLayer"><code>BetaML.Nn.ConvLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ConvLayer{ND, NDPLUS1, NDPLUS2} &lt;: AbstractLayer</code></pre><p>Representation of a convolutional layer in the network</p><p><strong>Fields:</strong></p><ul><li><p><code>input_size::StaticArraysCore.SVector{NDPLUS1, Int64} where NDPLUS1</code>: Input size (including nchannel_in as last dimension)</p></li><li><p><code>weight::Array{Float64, NDPLUS2} where NDPLUS2</code>: Weight tensor (aka &quot;filter&quot; or &quot;kernel&quot;) with respect to the input from previous layer or data (kernel<em>size array augmented by the nchannels</em>in and nchannels_out dimensions)</p></li><li><p><code>usebias::Bool</code>: Wether to use (and learn) a bias weigth [def: true]</p></li><li><p><code>bias::Vector{Float64}</code>: Bias (nchannels_out array)</p></li><li><p><code>padding_start::StaticArraysCore.SVector{ND, Int64} where ND</code>: Padding (initial)</p></li><li><p><code>padding_end::StaticArraysCore.SVector{ND, Int64} where ND</code>: Padding (ending)</p></li><li><p><code>stride::StaticArraysCore.SVector{ND, Int64} where ND</code>: Stride</p></li><li><p><code>ndims::Int64</code>: Number of dimensions (excluding input and output channels)</p></li><li><p><code>f::Function</code>: Activation function</p></li><li><p><code>df::Union{Nothing, Function}</code>: Derivative of the activation function</p></li><li><p><code>x_ids::Array{Tuple{Vararg{Int32, NDPLUS1}}, 1} where NDPLUS1</code>: x ids of the convolution (computed in <code>preprocessing</code><code>- itself at the beginning of</code>train`</p></li><li><p><code>y_ids::Array{Tuple{Vararg{Int32, NDPLUS1}}, 1} where NDPLUS1</code>: y ids of the convolution (computed in <code>preprocessing</code><code>- itself at the beginning of</code>train`</p></li><li><p><code>w_ids::Array{Tuple{Vararg{Int32, NDPLUS2}}, 1} where NDPLUS2</code>: w ids of the convolution (computed in <code>preprocessing</code><code>- itself at the beginning of</code>train`</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/ConvLayer.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.ConvLayer-Tuple{Any, Any, Any}" href="#BetaML.Nn.ConvLayer-Tuple{Any, Any, Any}"><code>BetaML.Nn.ConvLayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ConvLayer(
    input_size_with_channel,
    kernel_size,
    nchannels_out;
    stride,
    rng,
    padding,
    kernel_init,
    usebias,
    bias_init,
    f,
    df
) -&gt; ConvLayer{_A, _B, _C} where {_A, _B, _C}
</code></pre><p>Alternative constructor for a <code>ConvLayer</code> where the number of channels in input is specified as a further dimension in the input size instead of as a separate parameter, so to use <code>size(previous_layer)[2]</code> if one wish.</p><p>For arguments and default values see the documentation of the main constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/ConvLayer.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.DenseLayer" href="#BetaML.Nn.DenseLayer"><code>BetaML.Nn.DenseLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DenseLayer</p><p>Representation of a layer in the network</p><p><strong>Fields:</strong></p><ul><li><code>w</code>:  Weigths matrix with respect to the input from previous layer or data (n x n pr. layer)</li><li><code>wb</code>: Biases (n)</li><li><code>f</code>:  Activation function</li><li><code>df</code>: Derivative of the activation function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/DenseLayer.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.DenseNoBiasLayer" href="#BetaML.Nn.DenseNoBiasLayer"><code>BetaML.Nn.DenseNoBiasLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DenseNoBiasLayer</p><p>Representation of a layer without bias in the network</p><p><strong>Fields:</strong></p><ul><li><code>w</code>:  Weigths matrix with respect to the input from previous layer or data (n x n pr. layer)</li><li><code>f</code>:  Activation function</li><li><code>df</code>: Derivative of the activation function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/DenseNoBiasLayer.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.Learnable" href="#BetaML.Nn.Learnable"><code>BetaML.Nn.Learnable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Learnable(data)</p><p>Structure representing the learnable parameters of a layer or its gradient.</p><p>The learnable parameters of a layers are given in the form of a N-tuple of Array{Float64,N2} where N2 can change (e.g. we can have a layer with the first parameter being a matrix, and the second one being a scalar). We wrap the tuple on its own structure a bit for some efficiency gain, but above all to define standard mathematic operations on the gradients without doing &quot;type piracy&quot; with respect to Base tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L76-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.MultitargetNeuralNetworkRegressor" href="#BetaML.Nn.MultitargetNeuralNetworkRegressor"><code>BetaML.Nn.MultitargetNeuralNetworkRegressor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MultitargetNeuralNetworkRegressor &lt;: MLJModelInterface.Deterministic</code></pre><p>A simple but flexible Feedforward Neural Network, from the Beta Machine Learning Toolkit (BetaML) for regression of multiple dimensional targets.</p><p><strong>Parameters:</strong></p><ul><li><p><code>layers</code>: Array of layer objects [def: <code>nothing</code>, i.e. basic network]. See <code>subtypes(BetaML.AbstractLayer)</code> for supported layers</p></li><li><p><code>loss</code>: Loss (cost) function [def: <code>squared_cost</code>].  Should always assume y and ŷ as matrices.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If you change the parameter <code>loss</code>, you need to either provide its derivative on the parameter <code>dloss</code> or use autodiff with <code>dloss=nothing</code>.</p></div></div></li></ul><ul><li><p><code>dloss</code>: Derivative of the loss function [def: <code>dsquared_cost</code>, i.e. use the derivative of the squared cost]. Use <code>nothing</code> for autodiff.</p></li><li><p><code>epochs</code>: Number of epochs, i.e. passages trough the whole training sample [def: <code>1000</code>]</p></li><li><p><code>batch_size</code>: Size of each individual batch [def: <code>32</code>]</p></li><li><p><code>opt_alg</code>: The optimisation algorithm to update the gradient at each batch [def: <code>ADAM()</code>]</p></li><li><p><code>shuffle</code>: Whether to randomly shuffle the data at each iteration (epoch) [def: <code>true</code>]</p></li><li><p><code>descr</code>: An optional title and/or description for this model</p></li><li><p><code>cb</code>: A call back function to provide information during training [def: <code>fitting_info</code></p></li><li><p><code>rng</code>: Random Number Generator (see <a href="Api.html#BetaML.Api.FIXEDSEED"><code>FIXEDSEED</code></a>) [deafult: <code>Random.GLOBAL_RNG</code>]</p></li></ul><p><strong>Notes:</strong></p><ul><li>data must be numerical</li><li>the label should be a <em>n-records</em> by <em>n-dimensions</em> matrix </li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">julia&gt; using MLJ

julia&gt; X, y        = @load_boston;

julia&gt; ydouble     = hcat(y, y .*2  .+5);

julia&gt; modelType   = @load MultitargetNeuralNetworkRegressor pkg = &quot;BetaML&quot; verbosity=0
BetaML.Nn.MultitargetNeuralNetworkRegressor

julia&gt; layers                      = [BetaML.DenseLayer(12,50,f=BetaML.relu),BetaML.DenseLayer(50,50,f=BetaML.relu),BetaML.DenseLayer(50,50,f=BetaML.relu),BetaML.DenseLayer(50,2,f=BetaML.relu)];

julia&gt; model       = modelType(layers=layers,opt_alg=BetaML.ADAM(),epochs=500)
MultitargetNeuralNetworkRegressor(
  layers = BetaML.Nn.AbstractLayer[BetaML.Nn.DenseLayer([-0.2591582523441157 -0.027962845131416225 … 0.16044535560124418 -0.12838827994676857; -0.30381834909561184 0.2405495243851402 … -0.2588144861880588 0.09538577909777807; … ; -0.017320292924711156 -0.14042266424603767 … 0.06366999105841187 -0.13419651752478906; 0.07393079961409338 0.24521350531110264 … 0.04256867886217541 -0.0895506802948175], [0.14249427336553644, 0.24719379413682485, -0.25595911822556566, 0.10034088778965933, -0.017086404878505712, 0.21932184025609347, -0.031413516834861266, -0.12569076082247596, -0.18080140982481183, 0.14551901873323253  …  -0.13321995621967364, 0.2436582233332092, 0.0552222336976439, 0.07000814133633904, 0.2280064379660025, -0.28885681475734193, -0.07414214246290696, -0.06783184733650621, -0.055318068046308455, -0.2573488383282579], BetaML.Utils.relu, BetaML.Utils.drelu), BetaML.Nn.DenseLayer([-0.0395424111703751 -0.22531232360829911 … -0.04341228943744482 0.024336206858365517; -0.16481887432946268 0.17798073384748508 … -0.18594039305095766 0.051159225856547474; … ; -0.011639475293705043 -0.02347011206244673 … 0.20508869536159186 -0.1158382446274592; -0.19078069527757857 -0.007487540070740484 … -0.21341165344291158 -0.24158671316310726], [-0.04283623889330032, 0.14924461547060602, -0.17039563392959683, 0.00907774027816255, 0.21738885963113852, -0.06308040225941691, -0.14683286822101105, 0.21726892197970937, 0.19784321784707126, -0.0344988665714947  …  -0.23643089430602846, -0.013560425201427584, 0.05323948910726356, -0.04644175812567475, -0.2350400292671211, 0.09628312383424742, 0.07016420995205697, -0.23266392927140334, -0.18823664451487, 0.2304486691429084], BetaML.Utils.relu, BetaML.Utils.drelu), BetaML.Nn.DenseLayer([-0.11504184627266828 0.08601794194664503 … 0.03843129724045469 -0.18417305624127284; 0.10181551438831654 0.13459759904443674 … 0.11094951365942118 -0.1549466590355218; … ; 0.15279817525427697 0.0846661196058916 … -0.07993619892911122 0.07145402617285884; -0.1614160186346092 -0.13032002335149 … -0.12310552194729624 -0.15915773071049827], [-0.03435885900946367, -0.1198543931290306, 0.008454985905194445, -0.17980887188986966, -0.03557204910359624, 0.19125847393334877, -0.10949700778538696, -0.09343206702591, -0.12229583511781811, -0.09123969069220564  …  0.22119233518322862, 0.2053873143308657, 0.12756489387198222, 0.11567243705173319, -0.20982445664020496, 0.1595157838386987, -0.02087331046544119, -0.20556423263489765, -0.1622837764237961, -0.019220998739847395], BetaML.Utils.relu, BetaML.Utils.drelu), BetaML.Nn.DenseLayer([-0.25796717031347993 0.17579536633402948 … -0.09992960168785256 -0.09426177454620635; -0.026436330246675632 0.18070899284865127 … -0.19310119102392206 -0.06904005900252091], [0.16133004882307822, -0.3061228721091248], BetaML.Utils.relu, BetaML.Utils.drelu)], 
  loss = BetaML.Utils.squared_cost, 
  dloss = BetaML.Utils.dsquared_cost, 
  epochs = 500, 
  batch_size = 32, 
  opt_alg = BetaML.Nn.ADAM(BetaML.Nn.var&quot;#90#93&quot;(), 1.0, 0.9, 0.999, 1.0e-8, BetaML.Nn.Learnable[], BetaML.Nn.Learnable[]), 
  shuffle = true, 
  descr = &quot;&quot;, 
  cb = BetaML.Nn.fitting_info, 
  rng = Random._GLOBAL_RNG())

julia&gt; mach        = machine(model, X, ydouble);

julia&gt; fit!(mach);

julia&gt; ŷdouble    = predict(mach, X);

julia&gt; hcat(ydouble,ŷdouble)
506×4 Matrix{Float64}:
 24.0  53.0  28.4624  62.8607
 21.6  48.2  22.665   49.7401
 34.7  74.4  31.5602  67.9433
 33.4  71.8  33.0869  72.4337
  ⋮                   
 23.9  52.8  23.3573  50.654
 22.0  49.0  22.1141  48.5926
 11.9  28.8  19.9639  45.5823</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn_MLJ.jl#L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.NNHyperParametersSet" href="#BetaML.Nn.NNHyperParametersSet"><code>BetaML.Nn.NNHyperParametersSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>**`</p><pre><code class="language-julia hljs">mutable struct NNHyperParametersSet &lt;: BetaMLHyperParametersSet</code></pre><p>`**</p><p>Hyperparameters for the <code>Feedforward</code> neural network model</p><p><strong>Parameters:</strong></p><ul><li><p><code>layers</code>: Array of layer objects [def: <code>nothing</code>, i.e. basic network]. See <code>subtypes(BetaML.AbstractLayer)</code> for supported layers</p></li><li><p><code>loss</code>: Loss (cost) function [def: <code>squared_cost</code>] It must always assume y and ŷ as (n x d) matrices, eventually using <code>dropdims</code> inside.</p></li></ul><ul><li><p><code>dloss</code>: Derivative of the loss function [def: <code>dsquared_cost</code> if <code>loss==squared_cost</code>, <code>nothing</code> otherwise, i.e. use the derivative of the squared cost or autodiff]</p></li><li><p><code>epochs</code>: Number of epochs, i.e. passages trough the whole training sample [def: <code>1000</code>]</p></li><li><p><code>batch_size</code>: Size of each individual batch [def: <code>32</code>]</p></li><li><p><code>opt_alg</code>: The optimisation algorithm to update the gradient at each batch [def: <code>ADAM()</code>]</p></li><li><p><code>shuffle</code>: Whether to randomly shuffle the data at each iteration (epoch) [def: <code>true</code>]</p></li><li><p><code>tunemethod</code>: The method - and its parameters - to employ for hyperparameters autotuning. See <a href="Utils.html#BetaML.Utils.SuccessiveHalvingSearch"><code>SuccessiveHalvingSearch</code></a> for the default method. To implement automatic hyperparameter tuning during the (first) <code>fit!</code> call simply set <code>autotune=true</code> and eventually change the default <code>tunemethod</code> options (including the parameter ranges, the resources to employ and the loss function to adopt).</p></li></ul><p>To know the available layers type <code>subtypes(AbstractLayer)</code>) and then type <code>?LayerName</code> for information on how to use each layer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L789-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.NeuralNetworkClassifier" href="#BetaML.Nn.NeuralNetworkClassifier"><code>BetaML.Nn.NeuralNetworkClassifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct NeuralNetworkClassifier &lt;: MLJModelInterface.Probabilistic</code></pre><p>A simple but flexible Feedforward Neural Network, from the Beta Machine Learning Toolkit (BetaML) for classification  problems.</p><p><strong>Parameters:</strong></p><ul><li><p><code>layers</code>: Array of layer objects [def: <code>nothing</code>, i.e. basic network]. See <code>subtypes(BetaML.AbstractLayer)</code> for supported layers. The last &quot;softmax&quot; layer is automatically added.</p></li><li><p><code>loss</code>: Loss (cost) function [def: <code>crossentropy</code>]. Should always assume y and ŷ as matrices.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If you change the parameter <code>loss</code>, you need to either provide its derivative on the parameter <code>dloss</code> or use autodiff with <code>dloss=nothing</code>.</p></div></div></li></ul><ul><li><p><code>dloss</code>: Derivative of the loss function [def: <code>dcrossentropy</code>, i.e. the derivative of the cross-entropy]. Use <code>nothing</code> for autodiff.</p></li><li><p><code>epochs</code>: Number of epochs, i.e. passages trough the whole training sample [def: <code>1000</code>]</p></li><li><p><code>batch_size</code>: Size of each individual batch [def: <code>32</code>]</p></li><li><p><code>opt_alg</code>: The optimisation algorithm to update the gradient at each batch [def: <code>BetaML.ADAM()</code>]</p></li><li><p><code>shuffle</code>: Whether to randomly shuffle the data at each iteration (epoch) [def: <code>true</code>]</p></li><li><p><code>descr</code>: An optional title and/or description for this model</p></li><li><p><code>cb</code>: A call back function to provide information during training [def: <code>BetaML.fitting_info</code></p></li><li><p><code>categories</code>: The categories to represent as columns. [def: <code>nothing</code>, i.e. unique training values].</p></li><li><p><code>handle_unknown</code>: How to handle categories not seens in training or not present in the provided <code>categories</code> array? &quot;error&quot; (default) rises an error, &quot;infrequent&quot; adds a specific column for these categories.</p></li><li><p><code>other_categories_name</code>: Which value during prediction to assign to this &quot;other&quot; category (i.e. categories not seen on training or not present in the provided <code>categories</code> array? [def: <code>nothing</code>, i.e. typemax(Int64) for integer vectors and &quot;other&quot; for other types]. This setting is active only if <code>handle_unknown=&quot;infrequent&quot;</code> and in that case it MUST be specified if Y is neither integer or strings</p></li><li><p><code>rng</code>: Random Number Generator [deafult: <code>Random.GLOBAL_RNG</code>]</p></li></ul><p><strong>Notes:</strong></p><ul><li>data must be numerical</li><li>the label should be a <em>n-records</em> by <em>n-dimensions</em> matrix (e.g. a one-hot-encoded data for classification), where the output columns should be interpreted as the probabilities for each categories.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">julia&gt; using MLJ

julia&gt; X, y        = @load_iris;

julia&gt; modelType   = @load NeuralNetworkClassifier pkg = &quot;BetaML&quot; verbosity=0
BetaML.Nn.NeuralNetworkClassifier

julia&gt; layers      = [BetaML.DenseLayer(4,8,f=BetaML.relu),BetaML.DenseLayer(8,8,f=BetaML.relu),BetaML.DenseLayer(8,3,f=BetaML.relu),BetaML.VectorFunctionLayer(3,f=BetaML.softmax)];

julia&gt; model       = modelType(layers=layers,opt_alg=BetaML.ADAM())
NeuralNetworkClassifier(
  layers = BetaML.Nn.AbstractLayer[BetaML.Nn.DenseLayer([-0.376173352338049 0.7029289511758696 -0.5589563304592478 -0.21043274001651874; 0.044758889527899415 0.6687689636685921 0.4584331114653877 0.6820506583840453; … ; -0.26546358457167507 -0.28469736227283804 -0.164225549922154 -0.516785639164486; -0.5146043550684141 -0.0699113265130964 0.14959906603941908 -0.053706860039406834], [0.7003943613125758, -0.23990840466587576, -0.23823126271387746, 0.4018101580410387, 0.2274483050356888, -0.564975060667734, 0.1732063297031089, 0.11880299829896945], BetaML.Utils.relu, BetaML.Utils.drelu), BetaML.Nn.DenseLayer([-0.029467850439546583 0.4074661266592745 … 0.36775675246760053 -0.595524555448422; 0.42455597698371306 -0.2458082732997091 … -0.3324220683462514 0.44439454998610595; … ; -0.2890883863364267 -0.10109249362508033 … -0.0602680568207582 0.18177278845097555; -0.03432587226449335 -0.4301192922760063 … 0.5646018168286626 0.47269177680892693], [0.13777442835428688, 0.5473306726675433, 0.3781939472904011, 0.24021813428130567, -0.0714779477402877, -0.020386373530818958, 0.5465466618404464, -0.40339790713616525], BetaML.Utils.relu, BetaML.Utils.drelu), BetaML.Nn.DenseLayer([0.6565120540082393 0.7139211611842745 … 0.07809812467915389 -0.49346311403373844; -0.4544472987041656 0.6502667641568863 … 0.43634608676548214 0.7213049952968921; 0.41212264783075303 -0.21993289366360613 … 0.25365007887755064 -0.5664469566269569], [-0.6911986792747682, -0.2149343209329364, -0.6347727539063817], BetaML.Utils.relu, BetaML.Utils.drelu), BetaML.Nn.VectorFunctionLayer{0}(fill(NaN), 3, 3, BetaML.Utils.softmax, BetaML.Utils.dsoftmax, nothing)], 
  loss = BetaML.Utils.crossentropy, 
  dloss = BetaML.Utils.dcrossentropy, 
  epochs = 100, 
  batch_size = 32, 
  opt_alg = BetaML.Nn.ADAM(BetaML.Nn.var&quot;#90#93&quot;(), 1.0, 0.9, 0.999, 1.0e-8, BetaML.Nn.Learnable[], BetaML.Nn.Learnable[]), 
  shuffle = true, 
  descr = &quot;&quot;, 
  cb = BetaML.Nn.fitting_info, 
  categories = nothing, 
  handle_unknown = &quot;error&quot;, 
  other_categories_name = nothing, 
  rng = Random._GLOBAL_RNG())

julia&gt; mach        = machine(model, X, y);

julia&gt; fit!(mach);

julia&gt; classes_est = predict(mach, X)
150-element CategoricalDistributions.UnivariateFiniteVector{Multiclass{3}, String, UInt8, Float64}:
 UnivariateFinite{Multiclass{3}}(setosa=&gt;0.575, versicolor=&gt;0.213, virginica=&gt;0.213)
 UnivariateFinite{Multiclass{3}}(setosa=&gt;0.573, versicolor=&gt;0.213, virginica=&gt;0.213)
 ⋮
 UnivariateFinite{Multiclass{3}}(setosa=&gt;0.236, versicolor=&gt;0.236, virginica=&gt;0.529)
 UnivariateFinite{Multiclass{3}}(setosa=&gt;0.254, versicolor=&gt;0.254, virginica=&gt;0.492)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn_MLJ.jl#L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.NeuralNetworkEstimator" href="#BetaML.Nn.NeuralNetworkEstimator"><code>BetaML.Nn.NeuralNetworkEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong><code>NeuralNetworkEstimator</code></strong></p><p>A &quot;feedforward&quot; neural network (supervised).</p><p>For the parameters see <a href="Nn.html#BetaML.Nn.NNHyperParametersSet"><code>NNHyperParametersSet</code></a>.</p><p><strong>Notes:</strong></p><ul><li>data must be numerical</li><li>the label can be a <em>n-records</em> vector or a <em>n-records</em> by <em>n-dimensions</em> matrix, but the result is always a matrix.<ul><li>For one-dimension regressions drop the unnecessary dimension with <code>dropdims(ŷ,dims=2)</code></li><li>For classification tasks the columns should normally be interpreted as the probabilities for each categories</li></ul></li></ul><p><strong>Examples:</strong></p><ul><li>Classification...</li></ul><pre><code class="language-julia hljs">julia&gt; using BetaML

julia&gt; X = [1.8 2.5; 0.5 20.5; 0.6 18; 0.7 22.8; 0.4 31; 1.7 3.7];

julia&gt; y = [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;];

julia&gt; ohmod = OneHotEncoder()
A OneHotEncoder BetaMLModel (unfitted)

julia&gt; y_oh  = fit!(ohmod,y)
6×2 Matrix{Bool}:
 1  0
 0  1
 0  1
 0  1
 0  1
 1  0

julia&gt; layers = [DenseLayer(2,6),DenseLayer(6,2),VectorFunctionLayer(2,f=softmax)];

julia&gt; m      = NeuralNetworkEstimator(layers=layers,opt_alg=ADAM(),epochs=300,verbosity=LOW)
NeuralNetworkEstimator - A Feed-forward neural network (unfitted)

julia&gt; ŷ_prob = fit!(m,X,y_oh)
***
*** Training  for 300 epochs with algorithm ADAM.
Training..       avg ϵ on (Epoch 1 Batch 1):     0.4116936481380642
Training of 300 epoch completed. Final epoch error: 0.44308719831108734.
6×2 Matrix{Float64}:
 0.853198    0.146802
 0.0513715   0.948629
 0.0894273   0.910573
 0.0367079   0.963292
 0.00548038  0.99452
 0.808334    0.191666

julia&gt; ŷ      = inverse_predict(ohmod,ŷ_prob)
6-element Vector{String}:
 &quot;a&quot;
 &quot;b&quot;
 &quot;b&quot;
 &quot;b&quot;
 &quot;b&quot;
 &quot;a&quot;</code></pre><ul><li>Regression...</li></ul><pre><code class="language-julia hljs">julia&gt; using BetaML

julia&gt; X = [1.8 2.5; 0.5 20.5; 0.6 18; 0.7 22.8; 0.4 31; 1.7 3.7];

julia&gt; y = 2 .* X[:,1] .- X[:,2] .+ 3;

julia&gt; layers = [DenseLayer(2,6),DenseLayer(6,6),DenseLayer(6,1)];

julia&gt; m      = NeuralNetworkEstimator(layers=layers,opt_alg=ADAM(),epochs=3000,verbosity=LOW)
NeuralNetworkEstimator - A Feed-forward neural network (unfitted)

julia&gt; ŷ      = fit!(m,X,y);
***
*** Training  for 3000 epochs with algorithm ADAM.
Training..       avg ϵ on (Epoch 1 Batch 1):     33.30063874270561
Training of 3000 epoch completed. Final epoch error: 34.61265465430473.

julia&gt; hcat(y,ŷ)
6×2 Matrix{Float64}:
   4.1    4.11015
 -16.5  -16.5329
 -13.8  -13.8381
 -18.4  -18.3876
 -27.2  -27.1667
   2.7    2.70542</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L854-L947">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.NeuralNetworkEstimatorOptionsSet" href="#BetaML.Nn.NeuralNetworkEstimatorOptionsSet"><code>BetaML.Nn.NeuralNetworkEstimatorOptionsSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>NeuralNetworkEstimatorOptionsSet</p><p>A struct defining the options used by the Feedforward neural network model</p><p><strong>Parameters:</strong></p><ul><li><p><code>cache</code>: Cache the results of the fitting stage, as to allow predict(mod) [default: <code>true</code>]. Set it to <code>false</code> to save memory for large data.</p></li><li><p><code>descr</code>: An optional title and/or description for this model</p></li><li><p><code>verbosity</code>: The verbosity level to be used in training or prediction (see <a href="Api.html#BetaML.Api.Verbosity"><code>Verbosity</code></a>) [deafult: <code>STD</code>]</p></li><li><p><code>cb</code>: A call back function to provide information during training [def: <code>fitting_info</code></p></li><li><p><code>autotune</code>: 0ption for hyper-parameters autotuning [def: <code>false</code>, i.e. not autotuning performed]. If activated, autotuning is performed on the first <code>fit!()</code> call. Controll auto-tuning trough the option <code>tunemethod</code> (see the model hyper-parameters)</p></li><li><p><code>rng</code>: Random Number Generator (see <a href="Api.html#BetaML.Api.FIXEDSEED"><code>FIXEDSEED</code></a>) [deafult: <code>Random.GLOBAL_RNG</code>]</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L825-L833">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.NeuralNetworkRegressor" href="#BetaML.Nn.NeuralNetworkRegressor"><code>BetaML.Nn.NeuralNetworkRegressor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct NeuralNetworkRegressor &lt;: MLJModelInterface.Deterministic</code></pre><p>A simple but flexible Feedforward Neural Network, from the Beta Machine Learning Toolkit (BetaML) for regression of a single dimensional target.</p><p><strong>Parameters:</strong></p><ul><li><p><code>layers</code>: Array of layer objects [def: <code>nothing</code>, i.e. basic network]. See <code>subtypes(BetaML.AbstractLayer)</code> for supported layers</p></li><li><p><code>loss</code>: Loss (cost) function [def: <code>squared_cost</code>]. Should always assume y and ŷ as matrices, even if the regression task is 1-D</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If you change the parameter <code>loss</code>, you need to either provide its derivative on the parameter <code>dloss</code> or use autodiff with <code>dloss=nothing</code>.</p></div></div></li></ul><ul><li><p><code>dloss</code>: Derivative of the loss function [def: <code>dsquared_cost</code>, i.e. use the derivative of the squared cost]. Use <code>nothing</code> for autodiff.</p></li><li><p><code>epochs</code>: Number of epochs, i.e. passages trough the whole training sample [def: <code>1000</code>]</p></li><li><p><code>batch_size</code>: Size of each individual batch [def: <code>32</code>]</p></li><li><p><code>opt_alg</code>: The optimisation algorithm to update the gradient at each batch [def: <code>ADAM()</code>]</p></li><li><p><code>shuffle</code>: Whether to randomly shuffle the data at each iteration (epoch) [def: <code>true</code>]</p></li><li><p><code>descr</code>: An optional title and/or description for this model</p></li><li><p><code>cb</code>: A call back function to provide information during training [def: <code>fitting_info</code></p></li><li><p><code>rng</code>: Random Number Generator (see <a href="Api.html#BetaML.Api.FIXEDSEED"><code>FIXEDSEED</code></a>) [deafult: <code>Random.GLOBAL_RNG</code>]</p></li></ul><p><strong>Notes:</strong></p><ul><li>data must be numerical</li><li>the label should be be a <em>n-records</em> vector.</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">julia&gt; using MLJ

julia&gt; X, y        = @load_boston;

julia&gt; modelType   = @load NeuralNetworkRegressor pkg = &quot;BetaML&quot; verbosity=0
BetaML.Nn.NeuralNetworkRegressor

julia&gt; layers                      = [BetaML.DenseLayer(12,20,f=BetaML.relu),BetaML.DenseLayer(20,20,f=BetaML.relu),BetaML.DenseLayer(20,1,f=BetaML.relu)];

julia&gt; model       = modelType(layers=layers,opt_alg=BetaML.ADAM());
NeuralNetworkRegressor(
  layers = BetaML.Nn.AbstractLayer[BetaML.Nn.DenseLayer([-0.23249759178069676 -0.4125090172711131 … 0.41401934928739 -0.33017881111237535; -0.27912169279319965 0.270551221249931 … 0.19258414323473344 0.1703002982374256; … ; 0.31186742456482447 0.14776438287394805 … 0.3624993442655036 0.1438885872964824; 0.24363744610286758 -0.3221033024934767 … 0.14886090419299408 0.038411663101909355], [-0.42360286004241765, -0.34355377040029594, 0.11510963232946697, 0.29078650404397893, -0.04940236502546075, 0.05142849152316714, -0.177685375947775, 0.3857630523957018, -0.25454667127064756, -0.1726731848206195, 0.29832456225553444, -0.21138505291162835, -0.15763643112604903, -0.08477044513587562, -0.38436681165349196, 0.20538016429104916, -0.25008157754468335, 0.268681800562054, 0.10600581996650865, 0.4262194464325672], BetaML.Utils.relu, BetaML.Utils.drelu), BetaML.Nn.DenseLayer([-0.08534180387478185 0.19659398307677617 … -0.3413633217504578 -0.0484925247381256; 0.0024419192794883915 -0.14614102508129 … -0.21912059923003044 0.2680725396694708; … ; 0.25151545823147886 -0.27532269951606037 … 0.20739970895058063 0.2891938885916349; -0.1699020711688904 -0.1350423717084296 … 0.16947589410758873 0.3629006047373296], [0.2158116357688406, -0.3255582642532289, -0.057314442103850394, 0.29029696770539953, 0.24994080694366455, 0.3624239027782297, -0.30674318230919984, -0.3854738338935017, 0.10809721838554087, 0.16073511121016176, -0.005923262068960489, 0.3157147976348795, -0.10938918304264739, -0.24521229198853187, -0.307167732178712, 0.0808907777008302, -0.014577497150872254, -0.0011287181458157214, 0.07522282588658086, 0.043366500526073104], BetaML.Utils.relu, BetaML.Utils.drelu), BetaML.Nn.DenseLayer([-0.021367697115938555 -0.28326652172347155 … 0.05346175368370165 -0.26037328415871647], [-0.2313659199724562], BetaML.Utils.relu, BetaML.Utils.drelu)], 
  loss = BetaML.Utils.squared_cost, 
  dloss = BetaML.Utils.dsquared_cost, 
  epochs = 100, 
  batch_size = 32, 
  opt_alg = BetaML.Nn.ADAM(BetaML.Nn.var&quot;#90#93&quot;(), 1.0, 0.9, 0.999, 1.0e-8, BetaML.Nn.Learnable[], BetaML.Nn.Learnable[]), 
  shuffle = true, 
  descr = &quot;&quot;, 
  cb = BetaML.Nn.fitting_info, 
  rng = Random._GLOBAL_RNG())

julia&gt; mach        = machine(model, X, y);

julia&gt; fit!(mach);

julia&gt; ŷ    = predict(mach, X);

julia&gt; hcat(y,ŷ)
506×2 Matrix{Float64}:
 24.0  30.7726
 21.6  28.0811
 34.7  31.3194
  ⋮    
 23.9  30.9032
 22.0  29.49
 11.9  27.2438</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn_MLJ.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.PoolingLayer" href="#BetaML.Nn.PoolingLayer"><code>BetaML.Nn.PoolingLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct PoolingLayer{ND, NDPLUS1, NDPLUS2} &lt;: AbstractLayer</code></pre><p>Representation of a pooling layer in the network</p><p><strong>Fields:</strong></p><ul><li><p><code>input_size::StaticArraysCore.SVector{NDPLUS1, Int64} where NDPLUS1</code>: Input size (including nchannel_in as last dimension)</p></li><li><p><code>output_size::StaticArraysCore.SVector{NDPLUS1, Int64} where NDPLUS1</code>: Output size (including nchannel_out as last dimension)</p></li><li><p><code>kernel_size::StaticArraysCore.SVector{NDPLUS2, Int64} where NDPLUS2</code>: kernel<em>size augmented by the nchannels</em>in and nchannels_out dimensions</p></li><li><p><code>padding_start::StaticArraysCore.SVector{ND, Int64} where ND</code>: Padding (initial)</p></li><li><p><code>padding_end::StaticArraysCore.SVector{ND, Int64} where ND</code>: Padding (ending)</p></li><li><p><code>stride::StaticArraysCore.SVector{ND, Int64} where ND</code>: Stride</p></li><li><p><code>ndims::Int64</code>: Number of dimensions (excluding input and output channels)</p></li><li><p><code>f::Function</code>: Activation function</p></li><li><p><code>df::Union{Nothing, Function}</code>: Derivative of the activation function</p></li><li><p><code>y_to_x_ids::Array{Array{Tuple{Vararg{Int32, NDPLUS1}}, 1}, NDPLUS1} where NDPLUS1</code>: A y-dims array of vectors of ids of x(s) contributing to the giving y</p></li><li><p><code>preprocessed::Bool</code>: Wheather this layer has already been preprocessed</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/PoolingLayer.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.PoolingLayer-Tuple{Any, Any}" href="#BetaML.Nn.PoolingLayer-Tuple{Any, Any}"><code>BetaML.Nn.PoolingLayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PoolingLayer(
    input_size_with_channel,
    kernel_size;
    stride,
    padding,
    f,
    df
) -&gt; PoolingLayer{_A, _B, _C} where {_A, _B, _C}
</code></pre><p>Alternative constructor for a <code>PoolingLayer</code> where the number of channels in input is specified as a further dimension in the input size instead of as a separate parameter, so to use <code>size(previous_layer)[2]</code> if one wish.</p><p>For arguments and default values see the documentation of the main constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/PoolingLayer.jl#L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.ReshaperLayer" href="#BetaML.Nn.ReshaperLayer"><code>BetaML.Nn.ReshaperLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ReshaperLayer{NDIN, NDOUT} &lt;: AbstractLayer</code></pre><p>Representation of a &quot;reshaper&quot; (weigthless) layer in the network</p><p><strong>Fields:</strong></p><ul><li><p><code>input_size::StaticArraysCore.SVector{NDIN, Int64} where NDIN</code>: Input size</p></li><li><p><code>output_size::StaticArraysCore.SVector{NDOUT, Int64} where NDOUT</code>: Output size</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/ReshaperLayer.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.SGD" href="#BetaML.Nn.SGD"><code>BetaML.Nn.SGD</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SGD(;η=t -&gt; 1/(1+t), λ=2)</p><p>Stochastic Gradient Descent algorithm (default)</p><p><strong>Fields:</strong></p><ul><li><code>η</code>: Learning rate, as a function of the current epoch [def: t -&gt; 1/(1+t)]</li><li><code>λ</code>: Multiplicative constant to the learning rate [def: 2]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn_default_optalgs.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.ScalarFunctionLayer" href="#BetaML.Nn.ScalarFunctionLayer"><code>BetaML.Nn.ScalarFunctionLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ScalarFunctionLayer</p><p>Representation of a ScalarFunction layer in the network. ScalarFunctionLayer applies the activation function directly to the output of the previous layer (i.e., without passing for a weigth matrix), but using an  optional learnable parameter (an array) used as second argument, similarly to [<code>VectorFunctionLayer</code>(@ref). Differently from <code>VectorFunctionLayer</code>, the function is applied scalarwise to each node. </p><p>The number of nodes in input must be set to the same as in the previous layer</p><p><strong>Fields:</strong></p><ul><li><code>w</code>:   Weigths (parameter) array passes as second argument to the activation        function (if not empty)</li><li><code>n</code>:   Number of nodes in output (≡ number of nodes in input )</li><li><code>f</code>:   Activation function (vector)</li><li><code>dfx</code>: Derivative of the (vector) activation function with respect to the        layer inputs (x)</li><li><code>dfw</code>: Derivative of the (vector) activation function with respect to the        optional learnable weigths (w)         </li></ul><p><strong>Notes:</strong></p><ul><li>The output <code>size</code> of this layer is the same as those of the previous layers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/ScalarFunctionLayer.jl#L4-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.VectorFunctionLayer" href="#BetaML.Nn.VectorFunctionLayer"><code>BetaML.Nn.VectorFunctionLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>VectorFunctionLayer</p><p>Representation of a VectorFunction layer in the network. Vector function layer expects a vector activation function, i.e. a function taking the whole output of the previous layer an input rather than working on a single node as &quot;normal&quot; activation functions would do. Useful for example with the SoftMax function in classification or with the <code>pool1D</code> function to implement a &quot;pool&quot; layer in 1 dimensions. By default it is weightless, i.e. it doesn&#39;t apply any transformation to the output coming from the previous layer except the activation function. However, by passing the parameter <code>wsize</code> (a touple or array - tested only 1D) you can pass the learnable parameter to the activation function too. It is your responsability to be sure the activation function accept only X or also this  learnable array (as second argument).    The number of nodes in input must be set to the same as in the previous layer (and if you are using this for classification, to the number of classes, i.e. the <em>previous</em> layer must be set equal to the number of classes in the predictions).</p><p><strong>Fields:</strong></p><ul><li><code>w</code>:   Weigths (parameter) array passes as second argument to the activation        function (if not empty)</li><li><code>nₗ</code>:  Number of nodes in input (i.e. length of previous layer)</li><li><code>n</code>:   Number of nodes in output (automatically inferred in the constructor)</li><li><code>f</code>:   Activation function (vector)</li><li><code>dfx</code>: Derivative of the (vector) activation function with respect to the        layer inputs (x)</li><li><code>dfw</code>: Derivative of the (vector) activation function with respect to the        optional learnable weigths (w)         </li></ul><p><strong>Notes:</strong></p><ul><li>The output <code>size</code> of this layer is given by the size of the output function,</li></ul><p>that not necessarily is the same as the previous layers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/VectorFunctionLayer.jl#L4-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{AbstractLayer}" href="#Base.size-Tuple{AbstractLayer}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(layer)</code></pre><p>Get the size of the layers in terms of (size in input, size in output) - both as tuples</p><p><strong>Notes:</strong></p><ul><li>You need to use <code>import Base.size</code> before defining this function for your layer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L248-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{ConvLayer}" href="#Base.size-Tuple{ConvLayer}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(layer::ConvLayer) -&gt; Tuple{Tuple, Tuple}
</code></pre><p>Get the dimensions of the layers in terms of (dimensions in input, dimensions in output) including channels as last dimension</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/ConvLayer.jl#L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{PoolingLayer}" href="#Base.size-Tuple{PoolingLayer}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(layer::PoolingLayer) -&gt; Tuple{Tuple, Tuple}
</code></pre><p>Get the dimensions of the layers in terms of (dimensions in input, dimensions in output) including channels as last dimension</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/PoolingLayer.jl#L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.backward-Tuple{AbstractLayer, Any, Any}" href="#BetaML.Nn.backward-Tuple{AbstractLayer, Any, Any}"><code>BetaML.Nn.backward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">backward(layer,x,next_gradient)</code></pre><p>Compute backpropagation for this layer with respect to its inputs</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>:        Worker layer</li><li><code>x</code>:            Input to the layer</li><li><code>next_gradient</code>: Derivative of the overal loss with respect to the input of the next layer (output of this layer)</li></ul><p><strong>Return:</strong></p><ul><li>The evaluated gradient of the loss with respect to this layer inputs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L181-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.fitting_info-Tuple{Any, Any, Any}" href="#BetaML.Nn.fitting_info-Tuple{Any, Any, Any}"><code>BetaML.Nn.fitting_info</code></a> — <span class="docstring-category">Method</span></header><section><div><p>fitting<em>info(nn,x,y;n,batch</em>size,epochs,verbosity,n<em>epoch,n</em>batch)</p><p>Default callback funtion to display information during training, depending on the verbosity level</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li><li><code>x</code>:  Batch input to the network (batch_size,d)</li><li><code>y</code>:  Batch label input (batch_size,d)</li><li><code>n</code>: Size of the full training set</li><li><code>n_batches</code> : Number of baches per epoch</li><li><code>epochs</code>: Number of epochs defined for the training</li><li><code>verbosity</code>: Verbosity level defined for the training (NONE,LOW,STD,HIGH,FULL)</li><li><code>n_epoch</code>: Counter of the current epoch</li><li><code>n_batch</code>: Counter of the current batch</li></ul><p>#Notes:</p><ul><li>Reporting of the error (loss of the network) is expensive. Use <code>verbosity=NONE</code> for better performances</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L536-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.forward-Tuple{AbstractLayer, Any}" href="#BetaML.Nn.forward-Tuple{AbstractLayer, Any}"><code>BetaML.Nn.forward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forward(layer,x)</code></pre><p>Predict the output of the layer given the input</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>:  Worker layer</li><li><code>x</code>:      Input to the layer</li></ul><p><strong>Return:</strong></p><ul><li>An Array{T,1} of the prediction (even for a scalar)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L165-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.forward-Tuple{ConvLayer, Any}" href="#BetaML.Nn.forward-Tuple{ConvLayer, Any}"><code>BetaML.Nn.forward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forward(layer::ConvLayer, x) -&gt; Any
</code></pre><p>Compute forward pass of a ConvLayer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/ConvLayer.jl#L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.forward-Tuple{PoolingLayer, Any}" href="#BetaML.Nn.forward-Tuple{PoolingLayer, Any}"><code>BetaML.Nn.forward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forward(layer::PoolingLayer, x) -&gt; Any
</code></pre><p>Compute forward pass of a ConvLayer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/default_layers/PoolingLayer.jl#L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.get_gradient-Tuple{AbstractLayer, Any, Any}" href="#BetaML.Nn.get_gradient-Tuple{AbstractLayer, Any, Any}"><code>BetaML.Nn.get_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_gradient(layer,x,next_gradient)</code></pre><p>Compute backpropagation for this layer with respect to the layer weigths</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>:        Worker layer</li><li><code>x</code>:            Input to the layer</li><li><code>next_gradient</code>: Derivative of the overaall loss with respect to the input of the next layer (output of this layer)</li></ul><p><strong>Return:</strong></p><ul><li>The evaluated gradient of the loss with respect to this layer&#39;s trainable parameters as tuple of matrices. It is up to you to decide how to organise this tuple, as long you are consistent with the <code>get_params()</code> and <code>set_params()</code> functions. Note that starting from BetaML 0.2.2 this tuple needs to be wrapped in its <code>Learnable</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L214-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.get_gradient-Union{Tuple{N2}, Tuple{N1}, Tuple{T2}, Tuple{T}, Tuple{BetaML.Nn.NN, Union{AbstractArray{T, N1}, T}, Union{AbstractArray{T2, N2}, T2}}} where {T&lt;:Number, T2&lt;:Number, N1, N2}" href="#BetaML.Nn.get_gradient-Union{Tuple{N2}, Tuple{N1}, Tuple{T2}, Tuple{T}, Tuple{BetaML.Nn.NN, Union{AbstractArray{T, N1}, T}, Union{AbstractArray{T2, N2}, T2}}} where {T&lt;:Number, T2&lt;:Number, N1, N2}"><code>BetaML.Nn.get_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_gradient(nn,x,y)</p><p>Low level function that retrieve the current gradient of the weigthts (i.e. derivative of the cost with respect to the weigths). Unexported in BetaML &gt;= v0.9</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li><li><code>x</code>:   Input to the network (d,1)</li><li><code>y</code>:   Label input (d,1)</li></ul><p>#Notes:</p><ul><li>The output is a vector of tuples of each layer&#39;s input weigths and bias weigths</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L400-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.get_params-Tuple{AbstractLayer}" href="#BetaML.Nn.get_params-Tuple{AbstractLayer}"><code>BetaML.Nn.get_params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_params(layer)</code></pre><p>Get the layers current value of its trainable parameters</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>:  Worker layer</li></ul><p><strong>Return:</strong></p><ul><li>The current value of the layer&#39;s trainable parameters as tuple of matrices. It is up to you to decide how to organise this tuple, as long you are consistent with the <code>get_gradient()</code> and <code>set_params()</code> functions. Note that starting from BetaML 0.2.2 this tuple needs to be wrapped in its <code>Learnable</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L199-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.get_params-Tuple{BetaML.Nn.NN}" href="#BetaML.Nn.get_params-Tuple{BetaML.Nn.NN}"><code>BetaML.Nn.get_params</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_params(nn)</p><p>Retrieve current weigthts</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li></ul><p><strong>Notes:</strong></p><ul><li>The output is a vector of tuples of each layer&#39;s input weigths and bias weigths</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L384-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.init_optalg!-Tuple{ADAM}" href="#BetaML.Nn.init_optalg!-Tuple{ADAM}"><code>BetaML.Nn.init_optalg!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>init<em>optalg!(opt</em>alg::ADAM;θ,batch_size,x,y,rng)</p><p>Initialize the ADAM algorithm with the parameters m and v as zeros and check parameter bounds</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn_default_optalgs.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.init_optalg!-Tuple{BetaML.Nn.OptimisationAlgorithm}" href="#BetaML.Nn.init_optalg!-Tuple{BetaML.Nn.OptimisationAlgorithm}"><code>BetaML.Nn.init_optalg!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>init<em>optalg!(opt</em>alg;θ,batch_size,x,y)</p><p>Initialize the optimisation algorithm</p><p><strong>Parameters:</strong></p><ul><li><code>opt_alg</code>:    The Optimisation algorithm to use</li><li><code>θ</code>:         Current parameters</li><li><code>batch_size</code>:    The size of the batch</li><li><code>x</code>:   The training (input) data</li><li><code>y</code>:   The training &quot;labels&quot; to match</li><li><code>rng</code>: Random Number Generator (see <a href="Api.html#BetaML.Api.FIXEDSEED"><code>FIXEDSEED</code></a>) [deafult: <code>Random.GLOBAL_RNG</code>]</li></ul><p><strong>Notes:</strong></p><ul><li>Only a few optimizers need this function and consequently ovverride it. By default it does nothing, so if you want write your own optimizer and don&#39;t need to initialise it, you don&#39;t have to override this method</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L723-L738">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.preprocess!-Tuple{AbstractLayer}" href="#BetaML.Nn.preprocess!-Tuple{AbstractLayer}"><code>BetaML.Nn.preprocess!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preprocess!(layer::AbstractLayer)
</code></pre><p>Preprocess the layer with information known at layer creation (i.e. no data info used)</p><p>This function is used for some layers to cache some computation that doesn&#39;t require the data and it is called at the beginning of <code>fit!</code>. For example, it is used in ConvLayer to store the ids of the convolution.</p><p><strong>Notes:</strong></p><ul><li>as it doesn&#39;t depend on data, it is not reset by <code>reset!</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.set_params!-Tuple{AbstractLayer, Any}" href="#BetaML.Nn.set_params!-Tuple{AbstractLayer, Any}"><code>BetaML.Nn.set_params!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_params!(layer,w)</code></pre><p>Set the trainable parameters of the layer with the given values</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>: Worker layer</li><li><code>w</code>:     The new parameters to set (Learnable)</li></ul><p><strong>Notes:</strong></p><ul><li>The format of the tuple wrapped by Learnable must be consistent with those of the <code>get_params()</code> and <code>get_gradient()</code> functions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L231-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.set_params!-Tuple{BetaML.Nn.NN, Any}" href="#BetaML.Nn.set_params!-Tuple{BetaML.Nn.NN, Any}"><code>BetaML.Nn.set_params!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>set_params!(nn,w)</p><p>Update weigths of the network</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li><li><code>w</code>:  The new weights to set</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L482-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BetaML.Nn.single_update!-Tuple{Any, Any}" href="#BetaML.Nn.single_update!-Tuple{Any, Any}"><code>BetaML.Nn.single_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>single<em>update!(θ,▽;n</em>epoch,n<em>batch,batch</em>size,xbatch,ybatch,opt_alg)</p><p>Perform the parameters update based on the average batch gradient.</p><p><strong>Parameters:</strong></p><ul><li><code>θ</code>:         Current parameters</li><li><code>▽</code>:         Average gradient of the batch</li><li><code>n_epoch</code>:    Count of current epoch</li><li><code>n_batch</code>:    Count of current batch</li><li><code>n_batches</code>:  Number of batches per epoch</li><li><code>xbatch</code>:    Data associated to the current batch</li><li><code>ybatch</code>:    Labels associated to the current batch</li><li><code>opt_alg</code>:    The Optimisation algorithm to use for the update</li></ul><p><strong>Notes:</strong></p><ul><li>This function is overridden so that each optimisation algorithm implement their</li></ul><p>own version</p><ul><li>Most parameters are not used by any optimisation algorithm. They are provided</li></ul><p>to support the largest possible class of optimisation algorithms</p><ul><li>Some optimisation algorithms may change their internal structure in this function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/BetaML.jl/blob/0576143e0835a3938ef91264e2724ecbb6338222/src/Nn/Nn.jl#L693-L714">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Trees.html">« Trees</a><a class="docs-footer-nextpage" href="Clustering.html">Clustering »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 5 May 2023 12:32">Friday 5 May 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
